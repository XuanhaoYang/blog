---
title: 前端面经总结
---

# 自我介绍

分页器：

 pageNo：当前第几页

pageSize：每页需要展示多少条数据 

total：一共有多少数据    --->一共有多少页就知道了

continues：连续的页码数 5|7

1. 计算总页数

```js
computed: {
	totalPage(){
        return Math.ceil(this.total/this.pageSize);
    },
    startNumAndEndNum() {
        const {cotinues, pageSize, pageNo, totalPage} = this;
        let start = 0, end = 0;
    	if(continues > totalPage) { //总页数小于连续页数的情况
            start = 1;
            end = totalPage;
        } else{ //总页数大于连续页数的情况
            start = pageNo - parseInt(continues/2);
            end = pageNo + parseInt(continues/2);
            if(start < 1) { //起始页小于1的情况
                start = 1;
                end = continues;
            }
            if(end > totalPage) {
                end = totalPage;
                start = totalPage - continues + 1;
            }
        }
        
        return {start, end};
    }

}
```

2. 计算连续页的 start和end(分多种情况考虑 总页数小于连续页数 总页数大于连续页数 起始和结束页码不合法)
3. 动态显示 需要判断 ... 什么时候显示



项目优化的部分：

节流 防抖 路由懒加载 事件委托  keep-alive缓存组件，相同页面走缓存，不同页面重新获取数据

难点：

导航/路由守卫 



难点是登录后用户信息获取这一块的处理。一方面是业务逻辑比较复杂，另一方面是要考虑效率问题。

最开始是只在home页面派发了请求获取用户信息，获取到的token是存在vuex里的，由于vuex不能持久化存储，刷新后token就会消失，所以引入了localstorage用于存储token。但是这样完成后还是有个问题，当我点击不同的路由页面时，还是没有用户信息了，虽然token在，但是其他页面是没有派发请求用户信息的。在每个路由都去获取用户信息，这样频繁访问效率是比较低的。于是引入了全局前置路由守卫router.beforeEach。在全局路由首位中判断：

是否有token?

​	有 ｛去的是login?跳转home（已经登陆不需要在登陆）

​			没有用户信息？获取用户信息 （获取不到说明Token过期需要重新登录）		

​			有用户信息？ 正常放行	

​	｝

​	没有 ｛ 

去的是rade pay center相关的页面吗？是的话，

记录要去的地址，对于trade pay center相关的页面不能去，应该要跳转到登录页面并在url上记录重定向网址

不是的话正常放行	

｝

路由独享守卫beforeEnter(to,from,next)

trade页面必须由购物车来

pay页面必须由trade来

pay success页面必须由pay来

登录注册

<img src="C:\Users\YangXuanhao\AppData\Roaming\Typora\typora-user-images\image-20220728103508108.png" alt="image-20220728103508108" style="zoom:33%;" />

# HTML

## 行内元素有哪些？块级元素有哪些？ 空(void)元素有哪些？

行内元素：span、img、input...

- 和其他元素都在一行上；
- 高度、行高和顶以及底边距都不可改变；
- 宽度就是它的文字或图片的宽度，不可改变。
- 行内元素会在一条直线上排列，在同一行从左至右水平排列。直到一行排不下，才会换行。
- 行内元素设置宽、高、margin上下、padding上下无效（竖直无效）。
- 行内元素设置line-height，margin左右、padding左右有效（水平有效）。
- 行内元素的宽高随标签里的内容而变化。

块级元素：div、footer、header、section、p、h1...h6...

* 块级元素是指那些在浏览器显示中占据一行，并且排斥与其他元素统一行的元素。块级元素中可以设置 width、height、padding、margin 等属性。

元素之间的转换问题：
display: inline;  			把某元素转换成了行内元素      ===>不独占一行的，并且不能设置宽高
display: inline-block; 	把某元素转换成了行内块元素		 ===>不独占一行的，可以设置宽高
display: block;					把某元素转换成了块元素			   ===>独占一行，并且可以设置宽高

##  解释HTML模板的每一行含义

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  
</body>
</html>
```

```html
<!DOCTYPE html>
    <!--声明-->
```

　##  <!DOCTYPE> 声明

网页的第一个标签通常是`<!doctype>`，表示文档类型，告诉浏览器如何解析网页。

一般来说，只要像下面这样，简单声明`doctype`为`html`即可。浏览器就会按照 HTML 5 的规则处理网页。

有时，该标签采用完全大写的形式，以便区别于正常的 HTML 标签。因为`<!doctype>`本质上**不是标签**，更像一个**处理指令**。

## `<html>`

`<html>`标签是网页的顶层容器，即标签树结构的顶层节点，也称为根元素（root element），其他元素都是它的子元素。一个网页只能有一个`<html>`标签。

该标签的`lang`属性，表示网页内容默认的语言。

```
<html lang="zh-CN">
```

上面代码表示，网页是中文内容。如果是英文内容，`zh-CN`要改成`en`。

## `<head>`

`<head>`标签是一个容器标签，用于放置网页的元信息。它的内容不会出现在网页上，而是为网页渲染提供额外信息。

```
<!doctype html>
<html>
  <head>
    <title>网页标题</title>
  </head>
</html>
```

`<head>`是`<html>`的第一个子元素。如果网页不包含`<head>`，浏览器会自动创建一个。

`<head>`的子元素一般有下面七个，后文会一一介绍。

- `<meta>`：设置网页的元数据。
- `<link>`：连接外部样式表。
- `<title>`：设置网页标题。
- `<style>`：放置内嵌的样式表。
- `<script>`：引入脚本。
- `<noscript>`：浏览器不支持脚本时，所要显示的内容。
- `<base>`：设置网页内部相对 URL 的计算基准。

## `<meta>`

<meta>标签用于设置或说明网页的元数据，必须放在<head>里面。一个<meta>标签就是一项元数据，网页可以有多个<meta>。<meta>标签约定放在<head>内容的最前面。
不管什么样的网页，一般都可以放置以下两个`<meta>`标签。

```
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Page Title</title>
</head>
```

上面例子中，第一个`<meta>`标签表示网页采用 UTF-8 格式编码，第二个`<meta>`标签表示网页在手机端可以自动缩放。

<meta>标签有五个属性，下面依次介绍。**（1）charset 属性**



<meta>标签的charset属性，用来指定网页的编码方式。该属性非常重要，如果设置得不正确，浏览器可能无法正确解码，就会显示乱码。
```
<meta charset="utf-8">
```

上面代码声明，网页为 UTF-8 编码。虽然开发者可以使用其他的编码方式，但正确的做法几乎总是应该采用 UTF-8。

注意，这里声明的编码方式，应该与网页实际的编码方式一致，即声明了`utf-8`，网页就应该使用 UTF-8 编码保存。如果这里声明了`utf-8`，实际却是使用另一种编码（比如 GB2312），并不会导致浏览器的自动转码，网页可能会显示为乱码。

**（2）name 属性，content 属性**

<meta>标签的name属性表示元数据的名字，content属性表示元数据的值。它们合在一起使用，就可以为网页指定一项元数据。


```
<head>
  <meta name="description" content="HTML 语言入门">
  <meta name="keywords" content="HTML,教程">
  <meta name="author" content="张三">
</head>
```

上面代码包含了三个元数据：`description`是网页内容的描述，`keywords`是网页内容的关键字，`author`是网页作者。

元数据有很多种，大部分涉及浏览器内部工作机制，或者特定的使用场景，这里就不一一介绍了。下面是一些例子。

```
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="application-name" content="Application Name">
<meta name="generator" content="program">
<meta name="subject" content="your document's subject">
<meta name="referrer" content="no-referrer">
```

**（3）http-equiv 属性，content 属性**

<meta>标签的http-equiv属性用来覆盖 HTTP 回应的头信息字段，content属性是对应的字段内容。这两个属性与 HTTP 协议相关，属于高级用法，这里就不详细介绍了。


```
<meta http-equiv="Content-Security-Policy" content="default-src 'self'">
```

上面代码可以覆盖 HTTP 回应的`Content-Security-Policy`字段。

下面是另一些例子。

```
<meta http-equiv="Content-Type" content="Type=text/html; charset=utf-8">
<meta http-equiv="refresh" content="30">
<meta http-equiv="refresh" content="30;URL='http://website.com'">
```

## `<title>`

`<title>`标签用于指定网页的标题，会显示在浏览器窗口的标题栏。

```
<head>
  <title>网页标题</title>
</head>
```

搜索引擎根据这个标签，显示每个网页的标题。它对于网页在搜索引擎的排序，有很大的影响，应该精心安排，反映网页的主题。

`<title>`标签的内部，不能再放置其他标签，只能放置无格式的纯文本。

## `<body>`

`<body>`标签是一个容器标签，用于放置网页的主体内容。浏览器显示的页面内容，都放置在它的内部。它是`<html>`的第二个子元素，紧跟在`<head>`后面。

```
<html>
  <head>
    <title>网页标题</title>
  </head>
  <body>
    <p>hello world</p>
  </body>
</html>
```

## 网址的组成部分 

URL 由多个部分组成。下面是一个比较复杂的 URL，实际的 URL 通常不会有这么多部分。

```
https://www.example.com:80/path/to/myfile.html?key1=value1&key2=value2#anchor
```

我们看看，这个 URL 的各个部分。

**协议**

协议（scheme）是浏览器请求服务器资源的方法，上例是`https://`的部分，表示使用 HTTPS 协议。

互联网支持多种协议，必须指明网址使用哪一种协议，默认是 HTTP 协议。也就是说，如果省略协议，直接在浏览器地址栏输入`www.example.com`，那么浏览器默认会访问`http://www.example.com`。HTTPS 是 HTTP 的加密版本，出于安全考虑，越来越多的网站使用这个协议。

HTTP 和 HTTPS 的协议名称后面，紧跟着一个冒号和两个斜杠（`://`）。其他协议不一定如此，邮件地址协议`mailto:`的协议名后面只有一个冒号，比如`mailto:foo@example.com`。

**主机**

主机（host）是资源所在的网站名或服务器的名字，又称为域名。上例的主机是`www.example.com`。

有些主机没有域名，只有 IP 地址，比如`192.168.2.15`。这种情况常常出现在局域网。

**端口**

同一个域名下面可能同时包含多个网站，它们之间通过端口（port）区分。“端口”就是一个整数，可以简单理解成，访问者告诉服务器，想要访问哪一个网站。HTTP 协议的默认端口是80，如果省略了这个参数，服务器就会返回80端口的网站。

端口紧跟在域名后面，两者之间使用冒号分隔，比如`www.example.com:80`。

**路径**

路径（path）是资源在网站的位置。比如，`/path/index.html`这个路径，指向网站的`/path`子目录下面的网页文件`index.html`。

互联网的早期，路径是真实存在的物理位置。现在由于服务器可以模拟这些位置，所以路径只是虚拟位置。

               路径可能只包含目录，不包含文件名，比如`/foo/`，甚至结尾的斜杠都可以省略。这时，服务器通常会默认跳转到该目录里面的`index.html`文件（即等同于请求`/foo/index.html`），但也可能有其他的处理（比如列出目录里面的所有文件），这取决于服务器的设置。一般来说，访问`www.example.com`这个网址，很可能返回的是网页文件`www.example.com/index.html`。

**查询参数**

查询参数（parameter）是提供给服务器的额外信息。参数的位置是在路径后面，两者之间使用`?`分隔，上例是`?key1=value1&key2=value2`。

查询参数可以有一组或多组。每组参数都是键值对（key-value pair）的形式，同时具有键名(key)和键值(value)，它们之间使用等号（`=`）连接。比如，`key1=value`就是一个键值对，`key1`是键名，`value1`是键值。

多组参数之间使用`&`连接，比如`key1=value1&key2=value2`。

**锚点**

锚点（anchor）是网页内部的定位点，使用`#`加上锚点名称，放在网址的最后，比如`#anchor`。浏览器加载页面以后，会自动滚动到锚点所在的位置。

## title与h1的区别、b与strong的区别、i与em的区别？

```
title与h1的区别：

定义：
	title：概括了网站信息，可以告诉搜索引擎或者用户关于这个网站的内容主题是什么
	h1：文章主题内容，告诉蜘蛛（爬虫）我们的网站内容最主要是什么
区别：
	title他是显示在网页标题上、h1是显示在网页内容上
	title比h1添加的重要 (title > h1 ) ==》对于seo的了解
场景：
	网站的logo都是用h1标签包裹的	
```

```
b与strong的区别：

定义：
	b：实体标签，用来给文字加粗的。
	strong：逻辑标签，用来加强字符语气的。
区别：
	b标签只有加粗的样式，没有实际含义。
	strong表示标签内字符比较重要，用以强调的。
题外话：为了符合css3的规范，b尽量少用改用strong就行了。
```

```
i与em的区别：

定义：
	i:实体标签，用来做文字倾斜的。
	em：是逻辑标签，用来强调文字内容的
区别：
	i只是一个倾斜标签，没有实际含义。
	em表示标签内字符重要，用以强调的。
场景：
	i更多的用在字体图标，em术语上（医药，生物）。
```

## 你对HTML语义化的理解？

语义化是指使⽤**恰当语义的html标签，让页面具有良好的结构与含义**，⽐如`<p>`标签就代表段落， `<article>`代表正⽂内容等等。

 语义化的好处主要有两点：

*  **开发者友好**：使⽤语义类标签增强了可读性，开发者也能够清晰地看出⽹⻚的结构，也更为便于团队的开发和维护 
*  **机器友好**：带有语义的⽂字表现⼒丰富，更适合搜索引擎的爬⾍爬取有效信息，语义类还可以⽀持读屏软件，根据 ⽂章可以⾃动⽣成⽬录 这对于简书、知乎这种富⽂本类的应⽤很重要，语义化对于其⽹站的内容传播有很⼤的帮助，但是对于功能性的web软件重要性⼤打折扣，⽐如⼀个按钮、Skeleton这种组件根本没有对应的语义，也不需要什么SEO。

## 有哪些常用的meta标签？

meta标签由name和content两个属性来定义，来描述⼀个HTML⽹⻚⽂档的属性，例如作者、⽇期和时间、⽹⻚描述、 关键词、⻚⾯刷新等，除了⼀些http标准规定了⼀些name作为⼤家使⽤的共识，开发者也可以⾃定义。

<meta charset="UTF-8" >
http-equiv，顾名思义，相当于http的⽂件头作⽤,⽐如下⾯的代码就可以设置http的缓存过期⽇

＜meta http-equiv="expires" content="Wed, 20 Jun 2019 22:33:00 GMT"＞

viewport，移动前端最熟悉不过，Web开发⼈员可以控制视⼝的⼤⼩和⽐例

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
## src和href的区别？

* src是指向**外部资源**的位置，指向的内容会嵌⼊到⽂档中当前标签所在的位置，在请求src资源时会将其指向的资源 下载并应⽤到⽂档内，如js脚本，img图⽚和frame等元素。当浏览器解析到该元素时，会**暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕**，所以⼀般js脚本会放在底部⽽不是头部。 

* href是指向**网络资源**所在位置（的超链接），⽤来建⽴和当前元素或⽂档之间的连接，当浏览器识别到它他指向的文件时，就会**并行下载资源**，不会停⽌对当前⽂档的处理。

## script标签中的defer和async 延迟加载js代码

`defer`为了**解决脚本文件下载阻塞网页渲染的问题**，一个方法是对`<script>`元素加入`defer`属性。它的作用是延迟脚本的执行，等到 DOM 加载生成后，再执行脚本。

`defer`属性的运行流程如下。

1. 浏览器开始解析 HTML 网页。
2. 解析过程中，发现带有`defer`属性的`<script>`元素。
3. 浏览器继续往下解析 HTML 网页，同时**并行**下载`<script>`元素加载的外部脚本。
4. 浏览器**完成解析 HTML 网页，此时再回过头执行已经下载完成的脚本**。

`async`属性的作用是，使用**另一个进程下载脚本，下载时不会阻塞渲染**。

1. 浏览器开始解 析 HTML 网页。
2. 解析过程中，发现带有`async`属性的`script`标签。
3. 浏览器继续往下解析 HTML 网页，同时**并行**下载`<script>`标签中的外部脚本。
4. **脚本下载完成，浏览器暂停解析 HTML 网页，开始执行下载的脚本**。
5. 脚本执行完毕，浏览器**恢复解析 **HTML 网页。

`async`属性可以保证脚本下载的同时，浏览器继续渲染。需要注意的是，一旦采用这个属性，就**无法保证脚本的执行顺序**。哪个脚本先下载结束，就先执行那个脚本。

* `defer`属性和`async`属性到底应该使用哪一个？

一般来说，如果脚本之间没有依赖关系，就使用`async`属性，如果脚本之间有依赖关系，就使用`defer`属性。

明确: defer和 async的使用,可以**用于提升网页性能，只对外联script脚本文件有效, 内联script脚本设置无效**
script标签存在两个属性，defer和async，因此 script标签的使用分为三种情况：

<script src="example.js"></script>

没有defer或async属性，浏览器会立即加载并执行相应的脚本。
不等待后续加载的文档元素，读到就开始加载和执行，此举会阻塞后续文档的加载

<script async src="example.js"></script>

有了async属性，表示后续文档的加载和渲染与js脚本的加载和执行是并行进行的，即异步执行；

<script defer src="example.js"></script>

有了defer属性，加载后续文档的过程和js脚本的加载是并行进行的(异步)，此时的js脚本仅加载不
执行, js脚本的执行需要等到文档所有元素解析完成之后，DOMContentLoaded事件触发执行之
前。
下图是使用了 defer、async、和未使用时的运行情况对比：

![img](https://img-blog.csdnimg.cn/c78314887538458496efc135123874fb.png#pic_center)

绿线：HTML的解析时间
蓝线：JS脚本的加载时间
红色：JS脚本的执行时间
从图中我们可以明确一下几点：
1.defer和async在网络加载过程是一致的，都是异步执行的；(放在页面顶部,也不会阻塞页面的加
载,与页面加载同时进行)
2.两者的区别,脚本加载完成之后, async是立刻执行, defer会等一等 (等前面的defer脚本执行,等dom的加载)
所以, js脚本加上 async或 defer,放在头部可以减少网页的下载加载时间,如果不考虑兼容性,可以用于优化页面加载的性能

<script src="https://cdn.bootcdn.net/ajax/libs/vue/2.6.12/vue.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/element-ui/2.15.0/index.js"></script>


# CSS 

## CSS绘制三角形

```html
用border画 
div {
      width: 0;
      height: 0;
      border: 200px solid transparent;
      border-top-color: orange;
      margin: 40px auto;
    }
<div></div>
```

## CSS换行问题

```
word-break : normal | break-all | keep-all
```

normal : 依照亚洲语言和非亚洲语言的文本规则，允许在字内换行。

break-all : 该行为与亚洲语言的normal相同。**允许非亚洲语言文本行的任意字内断开**。该值适合包含一些非亚洲文本的亚洲文本。如果该行末端有个英文单词很长（congratulation等），它会把**单词截断**，变成该行末端为conra(congratulation的前端部分)，下一行为tulation（conguatulation）的后端部分了。

keep-all : 与所有非亚洲语言的normal相同。对于中文，韩文，日文，不允许字断开，**只能在半角空格或连字符处换行**。适合包含少量亚洲文本的非亚洲文本。

```
 word-wrap : normal | break-word
```

normal : 允许内容顶开指定的容器边界

break-word : 内容将在边界内换行。如果需要，词内换行（word-break）也行发生说明：设置或检索当当前行超过指定容器的边界时是否断开转行。

## CSS选择符有哪些？哪些属性可以继承？

```
CSS选择符：
    通配（*）
    id选择器（#）
    类选择器（.）
    标签选择器（div、p、h1...）
    相邻选择器(+)
    后代选择器(ul li)
    子元素选择器（ > ）
    属性选择器(a[href])
    
CSS属性哪些可以继承：
		文字系列：font-size、color、line-height、text-align...
***不可继承属性：border、padding、margin...
```

## **CSS选择器的优先级是怎样的？**

CSS选择器的优先级是：!important > 内联 > ID选择器 > 类选择器=属性=伪类 > 标签选择器=伪元素 > 通配符选择器 > 浏览器的自定义属性和继承

* 到具体的计算层面，优先级是由 A 、B、C、D 的值来决定的，其中它们的值计算规则如下：

  * A 的值等于 1 的前提是存在内联样式, 否则 A = 0;
  * B 的值等于 ID选择器 出现的次数;
  * C 的值等于 类选择器 和 属性选择器 和 伪类 出现的总次数;
  * D 的值等于 标签选择器 和 伪元素 出现的总次数 。

* 我们的比较优先级的方式是从A到D去比较值的大小，A、B、C、D权重从左到右，依次减小。判断优先级时，从左到右，一一比较，直到比较出最大值，即可停止。

  

## 伪类和伪元素的区别是什么？

伪类：本质上是为了**弥补**常规CSS**选择器的不足**，以便获取到更多信息 :

伪元素：是创建了一个**新元素** ::



伪类（pseudo-class） 是⼀个以冒号(:)作为前缀，被添加到⼀个选择器末尾的关键字，当你希望样式在特定状态下才被 呈现到指定的元素时，你可以往元素的选择器后⾯加上对应的伪类。

![img](https://img-blog.csdnimg.cn/20210219115510491.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjE5Mzc3OA==,size_16,color_FFFFFF,t_70#pic_center)

伪元素⽤于创建⼀些不在⽂档树中的元素，并为其添加样式。⽐如说，我们可以通过::before来在⼀个元素前增加⼀些 ⽂本，并为这些⽂本添加样式。虽然⽤户可以看到这些⽂本，但是这些⽂本实际上不在⽂档树中

![img](https://img-blog.csdnimg.cn/20210219115343969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjE5Mzc3OA==,size_16,color_FFFFFF,t_70#pic_center)

## 页面中使用CSS的方式主要有3种

* 外部样式表

  * CSS保存在.css文件中

  * 在HTML中使用`<link>`引用

  * ```html
    <style type="text/css" media="screen"> 
        @import url("CSS文件"); 
    </style>
    ```

* 内部样式表

  * 不使用外部CSS文件
  * 将CSS放在HTML`<style>`里

* 内联样式

  * 仅影响一个元素
  * 在HTML元素的style属性中添加



## CSS引用外部样式的方式

* link
  `<link rel="stylesheet" rev="stylesheet" href="CSS文件" type="text/css" media="all" />`

* @import

```html
<style type="text/css" media="screen"> 
    @import url("CSS文件"); 
</style>
```

* 区别
  * link属于html标签。@import在css中使用表示导入外部样式表；
  * 页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;
  * import只在IE5以上才能识别，而link是HTML标签，无兼容问题;
  * link方式的样式的权重 高于@import的权重；
  * link 支持使用javascript改变样式 （document.styleSheets），后者不可
* 区别一：link先有，后有@import（兼容性link比@import兼容）；
  区别二：加载顺序差别，浏览器先加载的标签link，后加载@import

## 有哪些方式（CSS）可以隐藏页面元素

1. opacity:0 元素的透明度化为零，隐藏，占据空间，**可以交互**

2. visibility:hiden 隐藏，占据空间，不可以交互

3. display:none **彻底隐藏，元素从文档流中消失**，不占据空间，不可以交互，**不影响布局**
4. transform:scale(0,0) 平面转换，将元素缩放为0，占据空间，不可以交互，类似visibility:hiden
5. overflow:hiden 隐藏元素溢出的部分，占据空间，不可以交互
6. z-index:-9999 将层级放到底部，被覆盖，看起来隐藏

7. 通过绝对定位把元素移到可视区域外

## em、px、rem、vw、vh区别？

* px：绝对单位，页面按精确像素展示。

* em：相对单位，基准点为⽗节点字体的⼤⼩，如果⾃身定义了font-size按⾃身来计算（浏览器默认字体是 16px），整个⻚⾯内1em不是⼀个固定的值。

* rem：相对单位，可理解为”root em”, 相对根节点html的字体⼤⼩来计算，CSS3新加属性，chrome/firefox/IE9+⽀ 持

  

* vw、vh、vmin、vmax是一种视窗单位，也是相对单位。它相对的不是父节点或者页面的根节点。而是由视窗（Viewport）大小来决定的，单位 1，代表类似于 1%。 视窗(Viewport)是你的浏览器实际显示内容的区域—，换句话说是你的不包括工具栏和按钮的网页浏览器。

  具体描述如下：

  vw：视窗宽度的百分比（1vw 代表视窗的宽度为 1%）

  vh：视窗高度的百分比

  vmin：取当前Vw和Vh中较小的那一个值

  vmax：取当前Vw和Vh中较大的那一个值

## 怎么让Chrome支持小于12px 的文字？

```
Chrome默认字体大小是：16px
**每个浏览器默认字体大小可能都不一样

<style type="text/css">
div{
	font-size:10px;
}
div span{
	display: inline-block;
	-webkit-transform:scale(1.6);
}
</style>
```

## 对flex的理解

移动端web应⽤有不同设备尺⼨和分辨率，这时需要**响应式界面设计**来满⾜复杂的布局需求，Flex弹性盒模型的优势在于开发 ⼈员只是声明**布局应该具有的行为**，⽽不需要给出具体的实现⽅式，浏览器负责完成实际布局，当布局涉及到**不定宽度，分布对齐**的场景时，就要优先考虑弹性盒布局。

## flex常用属性

1、常用的父级属性
[flex](https://so.csdn.net/so/search?q=flex&spm=1001.2101.3001.7020)-direction ：设置主轴的方向
justify-content ：设置主轴上的子元素排列方式
flex-wrap ：设置子元素是否换行
align-content ：设置侧轴上的子元素排列方式（多行）
align-items ：设置侧轴上的子元素排列方式（单行）
flex-[flow](https://so.csdn.net/so/search?q=flow&spm=1001.2101.3001.7020) ：复合属性，相当于同时设置了flex-direction和flex-wrap
1.1、flex-direction 设置主轴的方向
属性值 说明
row 默认值从左到右
row-reverse 从右到左
column 从上到下
column-reverse 从下到上
1.2、justify-content 设置主轴的子元素排列方式
justify-content 属性定义了项目在主轴上的对齐方式

注意：使用这个属性之前一定要确定好主轴是那个

属性值 说明
flex-start 默认值，从头部开始（如果主轴是X轴，则从左到右）
flex-end 从尾部开始排列
center 在主轴居中对齐（如果主轴是X轴，则水平居中）
space-around 平分剩余空间
space-between 先两边贴边，再平分剩余空间（重要）
1.3、flex-wrap 设置子元素是否换行
默认情况下，项目都排在一条线（又称“轴线”）上。flex-wrap属性定义，flex布局中默认是不换行的

属性值 说明
nowrap 默认值，不换行
wrap 换行
1.4、align-items设置侧轴上的子元素排列方式（单行）
该属性是控制子项在侧轴（默认是y轴）上的排列方式，在子项为‘单项’（单行）的时候使用

属性值 说明
flex-start 默认值，从上到下
flex-end 从下到上
center 挤在一起居中（垂直居中）
stretch 拉伸
1.5、align-content设置侧轴上的子元素排列方式（多行）
设置子项在侧轴上的排列方式，并且只能用于子项出现’换行’的情况(多行)，在单行下是没有效果的

属性值 说明
flex-start 默认值，在侧轴的头部开始排列
flex-end 在侧轴的尾部开始排列
center 在侧轴的中间显示
space-around 子项在侧轴平分剩余空间
space-between 子项在侧轴先分布在两头，再平分剩余空间
stretch 设置子项元素高度平分父元素高度
1.6、flex-flow
flex-flow 属性是 flex-direction 和 flex-wrap 属性的复合属性

2、常用的子项属性
flex：子项目占的份数
align-self： 控制子项在自己侧轴的排列方式
order： 属性定义子项的排列顺序（前后顺序）
2.1、flex 属性
flex: flex-grow flex-shrink flex-basis缩写

align-self 控制子项自己在侧轴上的排列方式

align-self 属性允许等那个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。

默认值为 auto ，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。

span:nth-child(2) {
/* 设置自己在侧轴上的排列方式 */
align-self: flex-end;
}

order 属性定义项目的排列顺序

数值越小，排列越靠前，默认为0.

注意：和 z-index 不一样。

span:nth-child(2) {
/* 设置自己的排列顺序 */
order: -1;
}

## 元素水平居中的方法？

* 行内元素 inline，在其父元素**使用text-align: center;**

 使用`text-align: center;`可以将块级元素（父元素）中的行内元素进行水平居中；直接给父元素设置 `text-align: center;` 即可。

```css
<style>
    #father {
        width: 500px;
        height: 300px;
        background-color: skyblue;
        text-align: center;
       }
</style>
 
<div id="father">
   <span id="son">我是行内元素</span>
</div>
```

* 块级元素block，**使用margin: 0 auto;**

  可以将块级元素（父元素）中具有固定宽度的块级元素进行水平居中；此时需要谁居中，就给其设置 `margin: 0 auto;` 

```css
<style>
    #father {
        width: 500px;
        height: 300px;
        background-color: skyblue;
    }
 
    #son {
        width: 100px;
        height: 100px;
        background-color: green;
        margin: 0 auto;
    }
</style>
 
<div id="father">
  <div id="son">我是块级元素</div>
</div>
```

* 浮动元素，使用position: relative;left:50%;transform: translateX(-50%);
* **使用flexbox布局实现**

使用flexbox布局，只需要给待处理的块状元素的父元素添加属性 `display: flex;` `justify-content: center;`

```
<style>
    #father {
        width: 500px;
        height: 300px;
        background-color: skyblue;
        display: flex;
        justify-content: center;
    }
 
    #son {
        width: 100px;
        height: 100px;
        background-color: green;
    }
</style>
 
<div id="father">
    <div id="son">我是块级元素</div>
</div>
```

* **使用定位属性**

首先设置父元素为相对定位，再设置子元素为绝对定位，设置子元素的left:50%，即让子元素的左上角水平居中；

```css
<style>
    #father {
        width: 500px;
        height: 300px;
        background-color: skyblue;
        position: relative;
}
 
    #son {
        height: 100px;
        background-color: green;
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
}
</style>
 
<div id="father">
    <div id="son">我是块级元素</div>
</div>
```

## 垂直居中

* **line-height** 子元素为文本的情况

```html
    div{
      height: 100px;
      line-height: 100px;
      background-color: royalblue;
    }
    
  <div>
    <span>垂直居中</span>
  </div>    
    
```

* **flex布局**

```css
    .fa{
      display: flex;
      /* align-items: center; */
      /* flex-direction: column;
      justify-content: center; */
      height: 400px;
      background-color: aqua;
    }
    .son{
      height: 50px;
      width: 50px;
      align-self:center;
      background-color: royalblue;
    }
```

* **绝对定位 + margin:auto 0**

```css
    .fa {
      position: relative;
      height: 400px;
      background-color: aquamarine;
    }
    .son {
      position: absolute;
      top: 0;
      bottom: 0;
      margin: auto 0;
      height: 100px;
      width: 100px;
      background-color: royalblue;
    }
    
  <div class="fa">
    <div class="son"></div>
  </div>    
    
```

* **绝对定位 + transform**

```css
    .fa {
      position: relative;
      height: 400px;
      background-color: aquamarine;
    }

    .son {
      position: absolute;
      height: 100px;
      width: 100px;
      top: 50%;
      transform: translateY(-50%);
      background-color: royalblue;
    }
  <div class="fa">
    <div class="son"></div>
  </div>
```

## 水平垂直居中

* 结构分布都如下：

```jsx
<div class="outerBox">
        <div class="innerBox"></div>
 </div>
```

* 第一种：flex布局



```css
 .outerBox1 {
            width: 400px;
            height: 400px;
            background-color: gray;
            display: flex;
            justify-content: center;
            align-items: center;
        }
 .innerBox1 {
            width: 200px;
            height: 200px;
            background-color: pink;
        }
```

* 第二种：定义line-height  text-align: center

常用于垂直居中盒子的文字，需要知道盒子高度,line-height就是盒子本身高度

```css
.outerBox2 {
            width: 200px;
            height: 200px;
            background-color: green;
            line-height: 200px;
            text-align: center;
        }
 .innerBox2 {
            color: white;
        }
```

* 第三种：position + margin:auto

父容器相对定位，子容器绝对定位并且上下左右设置为0，margin设置为auto



```css
.outerBox3 {
            width: 400px;
            height: 400px;
            background-color: gray;
            position: relative;
        }
.innerBox3 {
            width: 200px;
            height: 200px;
            background-color: pink;
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
            margin: auto;
        }
```

* 第四种：position + margin负边距

父容器相对定位，子容器绝对定位，left为50%，top为50%，margin-left为子容器宽度的一半，margin-top为子容器高度的一半
 （确定了当前div的宽度，margin值为当前div宽度一半的负值）



```css
.outerBox4 {
            width: 200px;
            height: 200px;
            background-color: green;
            position: relative;
        }
.innerBox4 {
            width: 100px;
            height: 100px;
            background-color: red;
            position: absolute;
            left: 50%;
            top: 50%;
            margin-left: -50px;
            margin-top: -50px;
        }
```

* 第五种：position + transform

父容器相对定位，子容器绝对定位，left为50%，top为50%，translate(-50%,-50%)
 （不确定当前盒子的宽高，采用 transform: translate(-50%,-50%)）



```css
.outerBox5 {
            width: 400px;
            height: 400px;
            background-color: gray;
            position: relative;
        }
.innerBox5 {
            width: 200px;
            height: 200px;
            background-color: pink;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
```

## CSS有几种定位方式?

1、static（静态定位）：

默认值。**没有定位**，当我们没有指定定位方式的时候，这时默认的定位方式就是static，也就是按照文档的书写布局自动分配在一个合适的地方，这种定位方式用margin来改变位置，**对left、top、z-index等设置值无效**，这种定位不脱离文档流；

2、relative（相对定位）：

相对定位是**参照于元素在文档流中的位置**定位的

可以通过设置left、top等值，使得指定元素相对其正常的位置进行偏移。

3、absolute（绝对定位）：

默认情况下依赖浏览器的左上角为定位基准;如果绝对定位的元素存在父、祖先元素且存在非static定位的时候该元素将依赖具备相对定位的元素来进行定位，而不是左上角。**脱离文档流**。

这种定位通过设置top、right、bottom、left这些偏移值，**相对于第一个非static定位的父元素、祖先元素进行定位**（这种定位通常设置父元素为relative定位来配合使用），在没有父元素的条件下，它的参照为**根元素**，该方式脱离文档流；

4、fixed（固定定位）：

生成绝对定位的元素，**相对于浏览器窗口进行定位**。只需设置它相对于各个方向的偏移值，就可以将该元素固定在页面固定的位置，通常用来显示一些提示信息，**脱离文档流**；

5、sticky：粘性定位，特性近似于relative和fixed的合体，其在实际应⽤中的近似效果就是IOS通讯录滚动的时候的 『顶屁股』

最初会被当作是relative，相对于原来的位置进行偏移；一旦超过一定阈值之后，会被当成fixed定位，相对于视口进行定位。

## CSS百分比定位和百分比尺寸

可以按照有没有脱离⽂档流来理解，⽆定位和相对定位都没有脱离⽂档流，其尺⼨和定位都是相对于⽗元素（⽆定位元素不能设置定位），⽽不论⽗元素有没有定位；绝对定位的元素脱离了⽂档流，只有已定位了的元素才能作为其尺⼨和位置的参照。

## 如何理解z-index？

CSS 中的z-index属性控制重叠元素的垂直叠加顺序，默认元素的z-index为0，我们可以修改z-index来控制元素的图层 位置，⽽且z-index只能影响设置了position值的元素。 我们可以把视图上的元素认为是⼀摞书的层叠，⽽⼈眼是俯视的视⻆，设置z-index的位置，就如同设置某⼀本书在这摞 书中的位置。

## 什么是层叠上下文

层叠上下文(stacking context)，是HTML中一个三维的概念。在CSS2.1规范中，每个盒模型的位置是三维的，分别是平面画布上的X轴，Y轴以及表示层叠的Z轴。一般情况下，元素在页面上沿X轴Y轴平铺，我们察觉不到它们在Z轴上的层叠关系。而一旦元素发生堆叠，这时就能发现某个元素可能覆盖了另一个元素或者被另一个元素覆盖。

如果一个元素含有层叠上下文，(也就是说它是层叠上下文元素)，我们可以理解为这个元素在Z轴上就“高人一等”，最终表现就是它离屏幕观察者更近。

## 清除浮动有哪些方法？

**（1）空标签 使用clear:both清除浮动**

在代码中在放一个空的div标签，然后给这个标签设置clear:both来清除浮动对页面的影响。它的优点是简单，方便兼容性好，但是一般情况下不建议使用该方法，因为会造成结构混乱，不利于后期维护

```css
<div style="clear: both"></div>
```

**（2）利用伪元素clearfix来清除浮动**

给父级元素添加了一个::after伪元素，通过清除伪元素的浮动，达到撑起父元素高度的目的

```css
.clearfix::after{
    content:"";
    display:block;
    clear:both;
    }
```

**（3）开启BFC**

**overflow方法的使用**

当给父元素设置了overflow样式，不管是overflow:hidden或overflow:auto都可以清除浮动只要它的值不为visible就可以了，它的本质就是建构了一个BFC，这样使得达到撑起父元素高度的效果

```css
.box{border:1px solid #ccc;background:#eff2f4;overflow: auto}
```

**（4）双伪元素方法的使用**

通过给父元素设置双伪元素来达到清除浮动的效果

```css
.clearfix:before,.clearfix:after{
    content:"";
    display:block;
    clear:both;
    }
```

## 谈谈对BFC的理解

BFC(Block Formatting Context) :块级格式化上下文，它是⼀块独⽴的区域，让处于BFC内部的元素与外部的元素互相隔离

BFC触发条件: 

* 根元素，即HTML元素 

* position: fixed/absolute 

* float 不为none 

* overflow不为visible 

* display的值为inline-block、flex

作用：

防⽌margin发⽣重叠

两栏布局，防⽌⽂字环绕等

防⽌元素塌陷

## 你对盒模型的理解

当对⼀个⽂档进⾏布局（layout）的时候，浏览器的渲染引擎会根据标准之⼀的 CSS 基础框盒模型（CSS basic box model），将所有元素表示为⼀个个矩形的盒⼦（box）。CSS 决定这些盒⼦的⼤⼩、位置以及属性（例如颜⾊、背 景、边框尺⼨…）。

```
CSS的盒子模型有哪些：标准盒子模型、IE盒子模型
CSS的盒子模型区别：
	标准盒子模型：margin、border、padding、content
	IE盒子模型 ：margin、content（ border +  padding  + content ）
通过CSS如何转换盒子模型：
	box-sizing: content-box;	/*标准盒子模型*/
	box-sizing: border-box;	  /*IE盒子模型*/
```

## line-height和height区别

```
line-height是每一行文字的高，如果文字换行则整个盒子高度会增大（行数*行高）。
height是一个死值，就是这个盒子的高度。
```



## 标准盒模型和怪异盒模型有什么区别？

在W3C标准下，我们定义元素的width值即为盒模型中的content的宽度值，height值即为盒模型中的content的⾼度值。

![image-20220707235628313](C:\Users\YangXuanhao\AppData\Roaming\Typora\typora-user-images\image-20220707235628313.png)

⽽IE怪异盒模型（IE8以下）width的宽度并不是content的宽度，⽽是border-left + padding-left + content的宽度值 + paddingright + border-right之和，height同理。

![image-20220707235731181](C:\Users\YangXuanhao\AppData\Roaming\Typora\typora-user-images\image-20220707235731181.png)

box-sizing: content-box // 标准盒模型 

box-sizing: border-box // 怪异盒模型



## 为什么有时候人们用translate来改变位置而不是定位？

 translate()是transform的⼀个值。改变transform或opacity不会触发浏览器重排（reflow）或重绘（repaint），只会 触发复合（compositions）。而改变绝对定位会触发重排，进而触发重绘和复合。transform使浏览器为元素创建⼀ 个 GPU 图层，但改变绝对定位会使⽤到 CPU。 因此translate()更⾼效，可以缩短平滑动画的绘制时间。 ⽽translate改变位置时，元素依然会占据其原始空间，绝对定位就不会发⽣这种情况。

## 双飞翼布局

写一个左中右布局占满屏幕，其中左、右俩块固定宽200，中间自适应宽，要求先加载中间块，请写出结构及样式。

```html
<style>
    *{
      margin: 0;
      border: 0;
      padding: 0;
    }
    body{
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    section{
      display: flex;
      flex-direction: row;
      flex:1;
      
    }
    .main{
      background-color: yellowgreen;
      flex-grow: 1;
    }
    .left{
      background-color: orange;
      order: -1;
    }
    .right{
      background-color: orchid;
    }
    div.left, div.right {
      flex:0 0 200px;
    }
    header, footer{
      height: 50px;
      background-color: cornflowerblue;
    }
</style>
```

```html
<body>
  <header>header</header>
  <section>
    <div class="main">main</div>
    <div class="left">left</div>
    <div class="right">right</div>
  </section>
  <footer>footer</footer>
</body>
```



## less语言相对于css的特性

Less （Leaner Style Sheets 的缩写） 是一门向后兼容的 CSS 扩展语言
Less为css添加了很多新的功能：

**变量**

```css
@width: 10px;
@height: @width + 10px;

#header {
  width: @width;
  height: @height;
}
```

**混合**
混合（Mixin）是一种将一组属性从一个规则集包含（或混入）到另一个规则集的方法（像下面这样输入所需属性的类（class）名称即可）

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210203162657786.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1ZldmVhbjI1NDUxMTYzMDk=,size_16,color_FFFFFF,t_70)



**嵌套**
Less 提供了使用[嵌套](https://so.csdn.net/so/search?q=嵌套&spm=1001.2101.3001.7020)代替层叠或与层叠结合使用的能力，即选择器可以套选择器
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210203162920886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1ZldmVhbjI1NDUxMTYzMDk=,size_16,color_FFFFFF,t_70)
& 表示当前选择器的父级,可以使用此方法将伪选择器与混合一同使用（栗子如下）
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210203163609496.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1ZldmVhbjI1NDUxMTYzMDk=,size_16,color_FFFFFF,t_70)

**@规则嵌套和冒泡**
@ 规则（例如 @media 或 @supports）可以与选择器以相同的方式进行嵌套。@ 规则会被放在前面，同一规则集中的其它元素的相对顺序保持不变。这叫做冒泡。
**运算**
算术运算符 +、-、*、/ 可以对任何数字、颜色或变量进行运算。

# JavaScript

## JS的数据类型

**值类型(基本类型)**：字符串（String）、数字(Number)、布尔(Boolean)、空（Null）、未定义（Undefined）、Symbol、bigInt（大整数）

**引用数据类型（对象类型）**：对象(Object)、数组(Array)、函数(Function)，还有两个特殊的对象：正则（RegExp）和日期（Date）。

NaN是一个数值类型，但是不是一个具体的数字。

## Symbol

**Symbol**是一种基本数据类型。`Symbol()`函数会返回**symbol**类型的值。该类型具有静态属性和静态方法。
 每个从`Symbol()`返回的symbol值都是唯一的。一个symbol值能作为对象属性的标识符。

使用场景

1、对象：创建私有成员、防止属性名冲突。
 2、Symbol的值是唯一的、独一无二的，不会重复。
 注意：不支持语法`new Symbol()`。

## null和undefined的区别

```
1. 作者在设计js的都是先设计的null（为什么设计了null：最初设计js的时候借鉴了java的语言）
2. 表示无最好不是对象，并且null会被隐式转换成0，很不容易发现错误。
3. 先有null后有undefined，出来undefined是为了填补之前的坑。
4. typeof的区别 null是object以为机器码最后三位是000，表示object类型


具体区别：JavaScript的最初版本是这样区分的：null是一个表示"无"的对象（空对象指针），转为数值时为0；undefined是一个表示"未定义"的原始值，转为数值时为NaN。
```

## typeof和instanceof的区别

* instanceof   

`instanceof`运算符返回一个布尔值，表示对象是否为某个构造函数的实例。

​						typeof              								instanceof                 

作用			检测数据类型							检测对象之间的关联性

返回 			小写字母字符串								布尔值

操作数		简单数据类型、函数、对象 	左边必须是引用类型 右边是类型

##  判断数据类型

1、typeof
使用typeof可以判断基本数据类型，在使用typeof判断引用数据类型时除了判断function时返回function类型，其他引用类型返回的都是object。并且返回的数据类型是字符串形式的小写
使用方法：typeof a
返回格式为：string

2、instanceof
使用instanceof可以判断已知的引用数据类型、不能判断基本数据类型。instanceof可以判断一个值是否属于某种类型、instanceof也可以判断在继承时一个实例是否属于它的父类型。可以通过构造函数的方式进行判断基本数据类型。
使用方法：[1,2,3,4] instanceof Array；

3、constructor
constructor是prototype对象上的属性，指向构造函数。constructor除了null和undefined无法判断，其他的数据类型都可以判断，但是对于继承类型的数据有可能会出错、因为Object被覆盖掉了,检测结果就不对了
使用方法：（[1,2,3,4]）.constructor
返回格式为：ƒ Array() { [native code] }

4.Object.prototype.toString.call()
Object.prototype.toString.call()是通用于所有的数据类型，返回的是构造函数的类型，
使用方法：Object.prototype.toString.call([1,2,3,4])
返回格式为：[object Array]

## 对于 `CommonJS` 和 ES6 中的模块化的两者区别是：

- 因为CommonJS的require语法是**同步**的，导致CommonJS只适合用于**服务端**；而ES6模块在**浏览器端和服务器端**都是可用的，但是在服务端需要遵循特殊的规则
- CommonJS模块输出的是一个**值的拷贝**，而ES6模块输出的是**值的引用**
- CommonJS模块是**运行时加载**；ES6模块是**编译时输出的接口**，方便对JS模块进行静态分析
- 关于互相引用问题，ES6模块中支持加载CommonJS；而CommonJS不支持引用ES6模块

## 什么是js垃圾回收机制 ?

js的垃圾回收机制就是**定时回收闲置资源**的一种机制 , **每隔一段时间, 执行环境都会清理内存中一些没用的变量释放它所占用的内存 **.

核心思想 : **找到没用的变量, 释放它们的内存**

**两种主要的回收策略**

标记清除
引用计数

1. 标记清除
标记清除是现在最常使用的垃圾回收策略, 使用标记清除作为垃圾回收机制的浏览器会在垃圾回收程序进行时会做如下几步 : 

* 标记内存中所有的变量
* 把在上下文(全局作用域, 脚本作用域)中声明的变量,以及在全局被引用的变量的标记删除掉, 剩下的所有带标记的变量就被视为要删除的变量, 垃圾回收执行时释放它们占用的内
* 内存清理, 清除垃圾
  伪代码简单说明一下 : 

    // 变量 color,dog 在全局环境下声明, 不会被清除
    const color = 'red';
    var dog = '金毛';
    {
      let cat = 'kitty'; // 变量 cat 在块作用域中声明, 且没有被全局所引用, 所以会在下一次垃圾 
                            回收执行时, 释放其内存
    }
2. 引用计数
引用计数是一种不常用的垃圾回收策略, 主要核心思路就是记录值被引用的次数, 一个值被赋给变量,引用次数+1, 这个变量在某个时刻重新赋了一个新值, 旧值的引用次数-1变为了0, 在下次垃圾回收程序进行时就会释放它的内存

引用计数存在的问题 : 循环引用
伪代码简单实例 : 

```
function fn() {
  const obj1 = new Object() // new Object 在堆内存中创建了一个对象1 {} 这个值被赋值给obj1 于是引用次数 + 1
  const obj2 = new Object() // new Object 在堆内存中创建了一个对象2 {} 这个值被赋值给obj2 于是引用次数 + 1
 
  obj1.a = obj2; // obj2 被赋值给 obj1的a属性  于是对象1的引用次数 1+1 = 2
  obj2.a = obj1; // obj1 被赋值给 obj2的a属性  于是对象2的引用次数 1+1 = 2
}
// 此时两个对象之间相互引用 且如果函数多次调用, 又会重新执行多次函数体, 又会多了n个相互引用的对象占用内存
```
为了避免循环引用的问题 : 我们可以手动将其设置为null

```
  obj1.a = null; 
  obj2.a = null; 
```
 //   通过设置为null 可以切断两者之间的引用, 在下次回收时就会清理释放掉
书写代码时的注意点 : 
闭包变量被外部引用时, 会造成内存泄漏, 在不使用时将其设置为null, 释放内存空间

## 前端设计模式

https://www.jianshu.com/p/4f3014fb8b8b

https://blog.csdn.net/qq_45845127/article/details/117450695

1. **工厂模式**

工厂模式是用来创建对象的一种最常用的设计模式，**不暴露创建对象的具体逻辑，而是将逻辑封装在一个函数中，那么这个函数就可以被视为一个工厂**。

工厂模式根据抽象程度的不同可以分为：简单工厂，工厂方法和[抽象工厂](https://so.csdn.net/so/search?q=抽象工厂&spm=1001.2101.3001.7020)，接下来，将对简单工厂和工厂方法在JavaScript中的运用举个简单的例子：

* 简单工厂
  简单工厂模式又叫静态工厂模式，由一个工厂对象决定创建某一种产品对象类的实例，主要用来创建同一类对象

比如说，在实际的项目中，我们常常需要根据用户的权限来渲染不同的页面，高级权限的用户所拥有的页面有些是无法被低级权限的用户所查看，所以我们可以在不同权限等级用户的构造函数中，保存该用户能够看到的页面。

```js
let UserFactory = function(role){
    function SuperAdmin(){
    this.name ='超级管理员',
    this.viewPage =[ '首页','用户管理','订单管理','应用管理'，'权限管理']
    }
    function Admin(){
    this.name ='管理员',
    this.viewPage = ['首页','订单管理','应用管理']
    }
    function Normaluser(){
    this .name ='普通用户',
    this.viewPage=['首页'，'订单管理']
    }
    switch (role){
    case 'superAdmin':
    return new SuperAdmin();
    break;
    case 'admin':
    return new Admin();
    break;
    case 'user':
    return new Normaluser();
    break;
    default:
    throw new Error('参数错误,可选参数:superAdmin、admin、user'}
}//调用
let superAdmin = UserFactory('superAdmin');
let admin = UserFactory('admin')
let normalUser= UserFactory('user')
```

总结：在上面的例子中，UserFactory就是一个简单工厂，在该函数中有3个构造函数分别对应不同的权限的用户，当我们调用工厂函数时，只需要传递superAdmin, admin, user这三个可选参数中的一个获取对应的实例对象

优点：简单工厂的优点在于，你只需要一个正确的参数，就可以获取到你所需要的对象，而无需知道其创建的具体细节;

缺点：在函数内包含了所有对象的创建逻辑(构造函数)和判断逻辑的代码，每增加新的构造函数还需要修改判断逻辑代码，我们的对象不是上面的3个而是30个或更多时，这个函数会成为一个庞大的超级函数，便得难以维护，简单工厂只能作用于创建的对象数量较少，对象的创建逻辑不复杂时使用。

* 工厂方法

* 工厂方法模式的本意是将实际创建对象的工作推迟到子类中，这样核心类就变成了抽象类，但是在JavaScript中很难像传统面向对象那样去实现创建抽象类，所以在JavaScript中我们只需要参考它的核心思想即可，我们可以将工厂方法看作是一个实例化对象的工厂类。

  比如说上面的例子，我们用工厂方法可以这样写，工厂方法我们只把它看作是一个实例化对象的工厂，它只做实例化对象这一件事情，我们采用安全模式创建对象。

  ![img](https://img-blog.csdnimg.cn/img_convert/2fdf5a708568e3e77314ef7e3092fbfa.png)

  **总结：**在简单工厂中，如果我们新增加一个用户类型，需要修改两个地方的代码，一个是增加新的用户构造函数，一个是在逻辑判断中增加对新的用户的判断，而在抽象工厂方法中，我们只需要在UserFactory.prototype中添加就可以啦。

2. **单例模式**

定义：是保证一个类只有一个实例，并且提供一个访问它的全局访问点。

需求：一些对象我们往往只需要一个，比如线程池、全局缓存、浏览器中的window对象、登录浮窗等。

实现：**用一个变量标识当前是否已经为某个类创建过对象，如果是，则在下一次获取这个类的实例时，直接返回之前创建的对象**。

**优点**：

- 可以用来划分命名空间，减少全局变量的数量
- 可以被实例化，且实例化一次，再次实例化生成的也是第一个实例

下面举个例子，在js中，我们可以使用闭包来创建实现这种模式：

![img](https://img-blog.csdnimg.cn/img_convert/d165efb84101660bc52bb9632f330193.png)

总结：在上面的代码中，我们可以使用single.getInstance来获取到例，并且每次调用均获取到同一个单例。

在我们平时的开发中，我们也经常会用到这种模式，比如当我们单击登录按钮的时候，页面中会出现一个登录框，而这个浮窗是唯一的，无论单击多少次登录按钮，这个浮窗只会被创建一次，因此这个登录浮窗就适合用单例模式。

3. **代理模式**

代理模式主要是**为其他对象提供一种代理以控制对这个对象的访问，主要解决在直接访问对象时带来的问题**。

比如说：要访问的对象在远程的机器上，在面向对象系统中，有些对象由于某些原因(比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问)，直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。

代理模式最基本的形式是对访问进行控制，代理对象和另一个对象(本体)实现的是同样的接口。

实际上工作还是本体在做，它才是负责执行所分派的任务的那个对象或类，代理对象所做的不外乎节制对本体的访问，代理对象并不会在另一对象的基础上添加方法或修改其方法，也不会简化那个对象的接口，它实现的接口与本体完全相同，所有对它进行的方法调用都会被传递给本体。
![img](https://img-blog.csdnimg.cn/img_convert/d08013b801c9fa60d1b6539f50a49640.png)

总结：在上面的代码中，Proxy可以控制对真正被代理对象的一个访问。在代理模式中，比较常见的就是虚拟代理，虚拟代理用于控制对那种创建开销很大的本体的访问，它会把本体的实例化推迟到有方法被调用的时候。

比如说，现在我们假设PublicLibrary的实例化很慢，不能在网页加载的时候立即完成，我们可以为其创建一个虚拟代理，让它把PublicLibrary的实例化推迟到必要的时候，比如说我们在前端中经常用到的图片懒加载，就可以用虚拟代理;

4. **观察者模式**

如果大家学过一些像vue，react这些框架，相信大家对观察者模式一定很熟悉，现在很多mvvm框架都用到了观察者模式这个思想，观察者模式又叫做发布—订阅模式。

它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知和更新，观察者模式提供了一个订阅模型，其中对象订阅事件并在发生时得到通知，这种模式是事件驱动的编程基石，它有利益于良好的面向对象的设计

定义：对象间的一种一对多的依赖关系。

需求：当一个对象的状态发生变化时，所有依赖于他的对象都将得到通知。

优点：时间上的解耦，对象之间的解耦。

实现：

指定好谁充当发布者;

给发布者添加一个缓存列表，用于存放回调函数以便通知订阅者;

发布消息的时候，发布者会遍历这个缓存列表，依次触发里面存放的订阅者回调函数。

下面举个例子，比如我们给页面中的一个dom节点绑定一个事件，其实就可以看做是一种观察者模式：

![img](https://img-blog.csdnimg.cn/img_convert/98309a857eaa984287c7f6e818932258.png)

总结：在上面的例子中，需要监听用户点击 document.body 的动作，但是我们是没办法预知用户将在什么时候点击的，因此我们订阅了 document.body 的 click 事件，当 body 节点被点击时，body 节点便会向订阅者发布 "Hello World" 消息。

## 解释下变量提升？

当 JavaScript 编译所有代码时，**编译时，所有使用 var 的变量声明都被提升到它们的函数/局部作用域的顶部**(如果在函数内部声明的话)，或者提升到它们的全局作用域的顶部(如果在函数外部声明的话)，而不管实际的声明是在哪里进行的。

**函数声明也会被提升，但是被提升到了最顶端，所以将位于所有变量声明之上。**

在编译阶段变量和函数声明会被放入内存中，但是你在代码中编写它们的位置会保持不变。



优先级：声明变量 > 声明普通函数 > 参数 > 变量提升

## js对象

1. 对象是通过new操作符构建出来的，所以对象之间不相等(除了引用外)；
2. 对象注意：引用类型(共同一个地址)；
3. 对象的key都是字符串类型；
4. 对象如何找属性|方法；
    查找规则：先在对象本身找 ===> 构造函数中找 ===> 对象原型中找 ===> 构造函数原型中找 ===> 对象上一层原型查找

## 判断变量是不是数组

**方式一：isArray**

```
var arr = [1,2,3];
console.log( Array.isArray( arr ) );
```

**方式二：instanceof  【可写,可不写】**

```
var arr = [1,2,3];
console.log( arr instanceof Array );
```

**方式三：原型prototype**

```
var arr = [1,2,3];
console.log( Object.prototype.toString.call(arr).indexOf('Array') > -1 );
```

**方式四：isPrototypeOf()**

```
var arr = [1,2,3];
console.log(  Array.prototype.isPrototypeOf(arr) )
```

**方式五：constructor**

```
var arr = [1,2,3];
console.log(  arr.constructor.toString().indexOf('Array') > -1 )
```

## ⼀段JavaScript代码是如何执行的？

先变量提升。

JavaScript 运行时，除了一个正在运行的主线程，引擎还提供一个任务队列（task queue），里面是各种需要当前程序处理的异步任务。（实际上，根据异步任务的类型，存在多个任务队列。为了方便理解，这里假设只存在一个队列。）

**首先，主线程会去执行所有的同步任务**。等到同步任务全部执行完，就会去看任务队列里面的异步任务。如果满足条件，那么异步任务就重新进入主线程开始执行，这时它就变成同步任务了。等到执行完，下一个异步任务再进入主线程开始执行。一旦任务队列清空，程序就结束执行。

异步任务的写法通常是回调函数。一旦异步任务重新进入主线程，就会执行对应的回调函数。如果一个异步任务没有回调函数，就不会进入任务队列，也就是说，不会重新进入主线程，因为没有用回调函数指定下一步的操作。

JavaScript 引擎怎么知道异步任务有没有结果，能不能进入主线程呢？答案就是引擎在不停地检查，一遍又一遍，只要同步任务执行完了，引擎就会去检查那些挂起来的异步任务，是不是可以进入主线程了。这种循环检查的机制，就叫做事件循环（Event Loop）。

##  闭包

闭包就是**函数嵌套时，内部函数够读外部函数的变量。由可以把闭包简单理解成“定义在一个函数内部的函数”**。闭包最大的特点，就是它可以“记住”诞生的环境，比如`f2`记住了它诞生的环境`f1`，所以从`f2`可以得到`f1`的内部变量。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。

作用：

1. **可以读取外层函数内部的变量，这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在**。（!! 正常情况下，函数执行完成，内部变量会被销毁。对于闭包 ，内部函数没有执行完成，外部函数变量不会销毁。）

2. 封装对象的私有属性和私有方法。
3. 封装函数、模块化开发（ 立即执行函数里return{add, sub}）

```js
function Person(name) {
  var _age;
  function setAge(n) {
    _age = n;
  }
  function getAge() {
    return _age;
  }

  return {
    name: name,
    getAge: getAge,
    setAge: setAge
  };
}

var p1 = Person('张三');
p1.setAge(25);
p1.getAge() // 25
```

## 使用闭包应该注意什么

**代码难以维护**： 闭包内部是可以访问上级作用域，改变上级作用域的私有变量，我们使用的使用一定要小心，不要随便改变上级作用域私有变量的值

**内存泄漏**： 程序的运行需要内存。对于持续运行的服务进程，必须及时释放不再用到的内存，否则占用越来越高，轻则影响系统性能，重则导致进程崩溃。不再用到的内存，没有及时释放，就叫做内存泄漏

使用闭包的注意点： 由于闭包会使得函数中的变量都保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄漏。解决方法是，在退出函数之前，将不使用的局部变量全部删除（引用设置为 null ，这样就解除了对这个变量的引用，其引用计数也会减少，从而确保其内存可以在适当的时机回收）

**this指向**： 闭包的this指向的是window

## JavaScript的作用域链理解吗？

各个作用域的嵌套关系组成一条作用域链。例子中 bar 函数的作用域链式 bar -> fn -> 全局， fn函数保存在作用域链式 fn -> 全局
作用域链主要是进行标识符（变量和函数）的查询，标识符解析就是沿着作用域链一级一级的搜索标识符的过程，而作用域链就是保证对变量和函数的有序访问。

**一般情况下，变量取值到 创建 这个变量 的函数的作用域中取值。**

**但是如果在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链。**

## for ... in ... 和 for ... of ... 区别

**for…in**

用于迭代对象的所有**'可枚举'属性(key)，包括继承的可枚举属性**, 该迭代语句**可用于数组/字符串或普通对象**，但**不能用于Map或Set对象。顺序是任意的。如需迭代当前对象的可枚举属性，可以使用 obj.hasOwnProperty(key)进行拦截**。

**for..of**

适用遍历**数组/字符串/map/set等拥有迭代器对象**的集合.但是**不能遍历普通对象(除非用Object.keys())**,因为没有迭代器对象.与forEach()不同的是，它可以正确响应break、continue和return语句。遍历的是**值(value)**。

##  简述var、let、const三者的区别

前二者为定义变量，const一般用来定义常量。

1、var声明变量可以重复声明，而let不可以重复声明

```
1  var name = 'xiaohuang';
2  var name = 'xiaolan';
3  console.log(name);//xiaolan
1 let name = 'xiaohuang';
2 let name = 'xiaolan';
3 console.log(name);//报错'name' has already been declared
```

2、var是不受限于块级的，而let是受限于块级

```
1 {
2     var a = 10;
3 }
4 console.log(a);//10//在花括号外面和里面打印都会出来10
1 {
2     let a = 10;
3 }
4 console.log(a);//Uncaught ReferenceError: a is not defined
5 //而let声明，只能在花括号里面打印，在外面打印就报错了
```

3、var会与window相映射（会挂一个属性），而let不与window相映射

```
1 var m = 20;
2 console.log(window);
```

![img](https://img2018.cnblogs.com/blog/1329995/201812/1329995-20181212235823486-142909955.jpg)

```
1 let m = 20;
2 console.log(window);
```

![img](https://img2018.cnblogs.com/blog/1329995/201812/1329995-20181212235947040-1562242155.jpg)

 

同理，var可以引用全局对象，而let不可以

```
1 var user = '小明';
2 console.log(window.user);//小明
1 let user = '小明';
2 console.log(window.user);//undefined
```

4、var可以在声明的上面访问变量，而let有暂存死区，在声明的上面访问变量会报错

```
1 console.log(bosh);//undefined
2 var bosh = 100;
1 console.log(bosh);//ReferenceError: bosh is not defined
2 let bosh = 100;
```

最后说下const，const有以下几个特性

1）声明之后必须赋值，否则会报错

```
1  const arr;
2  console.log(arr);//Missing initializer in const declaration
```

2）定义不可变的量，改变了就会报错

```
1 const num = 100;
2 const num = 200;
3 console.log(lis);//Identifier 'num' has already been declared
```

3）不会与window相映射（不在window上挂一个属性）

4）支持块级作用域，只要有{}都支持块级

5）在声明的上面访问变量会报错

6）可以改变定义的对象

注：后三个特性和let一样，就不举例子了~

##  ==和===的区别

* 简单说，它们的区别是相等运算符（`==`）比较两个值是否相等，严格相等运算符（`===`）比较它们是否为“同一个值”。如果两个值不是同一类型，严格相等运算符（`===`）直接返回`false`，而相等运算符（`==`）会将它们转换成同一个类型，再用严格相等运算符进行比较。

**严格相等运算符 ===**

**（1）不同类型的值**

如果两个值的类型不同，直接返回`false`。

**（2）同一类的原始类型值**

同一类型的原始类型的值（数值、字符串、布尔值）比较时，值相同就返回`true`，值不同就返回`false`。

需要注意的是，`NaN`与任何值都不相等（包括自身）。另外，正`0`等于负`0`

**（3）复合类型值**

两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个地址。

**（4）undefined 和 null**

`undefined`和`null`与自身严格相等。

**相等运算符 ==**

* 相等运算符用来比较相同类型的数据时，与严格相等运算符完全一样。

* 比较不同类型的数据时，相等运算符会先将数据进行类型转换，然后再用严格相等运算符比较。下面分成几种情况，讨论不同类型的值互相比较的规则。

**（1）原始类型值**

原始类型的值会转换成数值再进行比较。

**（2）对象与原始类型值比较**

对象（这里指广义的对象，包括数组和函数）与原始类型的值比较时，对象转换成原始类型的值，再进行比较。

具体来说，先调用对象的`valueOf()`方法，如果得到原始类型的值，就按照上一小节的规则，互相比较；如果得到的还是对象，则再调用`toString()`方法，得到字符串形式，再进行比较。

**（3）undefined 和 null**

`undefined`和`null`只有与自身比较，或者互相比较时，才会返回`true`；与其他类型的值比较时，结果都为`false`。

##  布尔值

JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为`false`，其他值都视为`true`。

- `undefined`
- `null`
- `false`
- `0`
- `NaN`
- `""`或`''`（空字符串）

##  对调两个变量的多种方法

1. 临时变量法 内存不友好

```
var a = 3, b = 5, c = b;
b = a;
a = c;
```

2. 加减法

```
var a = 3, b = 5;
a = a + b;
b = a - b;
a = a - b;
```

3. 数组法

```
var a = 3, b = 5;
a = [a, b];
b = a[0];
a = a[1];
```

4. 对象法

```
var a = 3, b = 5;
a = {a:b, b:a};
b = a.b;
a = a.a;
```

5. 数组运算法

```
var a = 3, b = 5;
a = [b, b = a][0];
```

6. 按位异或法

```
var a = 3, b = 5;
a = a ^ b;
b = a ^ b;
a = a ^ b;
```

7. 解构赋值法

```
var a = 3, b = 5;
[a, b] = [b, a];
```

## 合并对象的方法

方式一：Object.assign

```
const a = {a:1,b:4};
const b = {b:2,c:3};

let obj1 = Object.assign(a,b);
console.log( obj1 );
```

方式二：...

```
let obj2 = {...a,...b};
console.log( obj2 );
```

方式三：自己封装方法

```
function extend( target,  source ){
	for(var key in source){
		target[key] = source[key];
	}
	return target;
}
console.log( extend(a,b) );
```

## 删除有序数组中的重复项(数组去重)

leetcode26题

* new Set
* indexOf

* 遍历删除法

```js
    for(let i = 0; i < nums.length - 1; i++) {
        if (nums[i] == nums[i + 1]) {
            nums.splice(i + 1, 1);
            i--;
        }
    }
    return nums.length;
```

* 双指针法

```js
if (nums.length == 0) return 0;
    let slow = 0, fast = 0;
    while(fast < nums.length) {
        if(nums[slow] != nums[fast]){
            nums[++slow] = nums[fast];
        }
        fast++;
    }
    return slow + 1;
```

##  打乱数组内元素顺序

```js
function shuttle(arr) {
    let i = arr.length;
    while(i--) {
      console.log(i);
      let index = Math.floor(Math.random() * i);
      [arr[index], arr[i]] = [arr[i], arr[index]];
    }
    return arr;
  }
```

##  JS new一个对象的过程

使用`new`命令时，它后面的函数依次执行下面的步骤。

1. 创建一个空对象，作为将要返回的对象实例。
2. 将这个空对象的原型`__proto__`，指向构造函数的`prototype`属性。
3. 执⾏构造函数，为这个新对象添加属性，并将this指向创建的新对象obj。。
4. 当构造函数本⾝返回值为对象时，返回该对象，否则返回新对象；

## 手写new

```js
  function _new(constructer, ...args) {
    // 创建一个空对象
    let resultObj = {};
    // 对象的原型指向构造函数的原型
    resultObj.__proto__ = constructer.prototype;
    // 构造函数的this赋给空对象,并执行构造函数
    let result = constructer.call(resultObj, ...args);
    // 如果该函数有没有返回对象，没有则返回this；
    return (typeof result == 'object' && result != null) ? result : resultObj;
  }
```

```js
new方法的效果：
function Person(name, age) {
     this.name = name;
     this.age = age;
}
let Person1 = _new(Person, 'lucy', '18');
let Person2 = _new(Person, 'chuan', '20');
console.log(Person1.name); // 'lucy'
console.log(Person1.name); // 'chuan'
console.log(Person1 instanceof Person); // true
console.log(Person2 instanceof Person); // true
```

## sort()方法

默认是按照unicode排序

回调原则，小于零，保持原数组位置不变，(a,b)=>a-b 升序

##  0.1 + 0.2为什么不等于0.3？

在于在JS中采用的**IEEE 754的双精度标准**，计算机内部存储数据的编码的时候，0.1在计算机内部根本就不是精确的0.1，而是一个有舍入误差的0.1。

##  箭头函数和普通函数的区别？

**外形不同**：箭头函数使用箭头定义，普通函数中没有

**箭头函数都是匿名函数**

**箭头函数不能用于构造函数，不能使用new**

**箭头函数中this的指向不同（跟随最近的普通函数的this指向），且不能修改**

**箭头函数不绑定arguments，取而代之用扩展运算符**

## 谈⼀谈你对this的了解？

`this`就是属性或方法“当前”所在的对象。

this的指向不是在编写时确定的，而是在执行时确定的，同时，this不同的指向在于遵循了⼀定的规则

* 默认绑定
  * 首先，在默认情况下，this是指向全局对象的，⽐如在浏览器就是指向window

* 隐式绑定
  * 其次，如果函数被调用的位置存在上下文对象时，那么函数是被隐式绑定的。

* 显示绑定
  * 再次，显示改变this指向，常见的方法就是call、apply、bind

*  new 绑定
  * 优先级最高的绑定是 new 绑定
  * ⽤ new 调用⼀个构造函数，会创建⼀个新对象, 在创造这个新对象的过程中,新对象会⾃动绑定到Person对象的this上， 那么 this ⾃然就指向这个新对象
* 绑定优先级: new绑定 > 显式绑定 >隐式绑定 >默认绑定

##  那么箭头函数的this指向哪里？

跟随最近的普通函数的this指向

**箭头函数**：出现的作用除了让函数的书写变得很简洁，可读性很好外；最大的优点是解决了this执行环境所造成的一些问题。比如：解决了匿名函数this指向的问题（匿名函数的执行环境具有全局性），包括setTimeout和setInterval中使用this所造成的问题，以及闭包this默认绑定在windows，常常需要访问嵌套函数的this。

## call apply bind区别

作用：可以指定函数内部`this`的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。

* call

函数实例的`call`方法，可以指定函数内部`this`的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。

使用格式：`func.call(thisValue, arg1, arg2, ...)`

`call`的第一个参数就是`this`所要指向的那个对象，后面的参数则是函数调用时所需的参数。

`call`方法的一个应用是调用对象的原生方法:`Object.prototype.toString.call(value)`

* apply

`apply`方法的作用与`call`方法类似，也是改变`this`指向，然后再调用该函数。唯一的区别就是，它接收一个数组作为函数执行时的参数，使用格式如下。`func.apply(thisValue, [arg1, arg2, ...])`

* bind

`bind()`除了返回是函数以外，它的参数和 call 一样。

使用格式：`func.bind(thisValue, arg1, arg2, ...)`

1、call、apply、bind三个方法都有两个参数；第一个参数都是this(对象)；

2、call和apply都是立即执行函数，不必调用。call第二个参数不用数组接收，apply用数组接收，类型可以是任意类型

3、bind返回值是一个函数（不会立即执行，需要调用），传参和call一样

## find和filter的区别

```
区别一：返回的内容不同
	filter 返回是新数组
	find   返回具体的内容
区别二：
	find ：匹配到第一个即返回
	filter ： 返回整体（没一个匹配到的都返回）
```

## some和every的区别

```
some  ==》 如果有一项匹配则返回true
every ==》 全部匹配才会返回true
```

## 手写call apply bind

* call

```js
  // ES6
  // Function.prototype.newCall = function (obj, ...args) {
  //   obj = obj || window;
  //   obj.fn = this;
  //   let result = obj.fn(...args);
  //   delete obj.fn;
  //   return result;
  // };
```

* apply

```js
  //ES6
  function person(a,b) {  
    console.log(this.name)
    return {a, b};
  }
  let cat = {
    name:'喵喵',
  };
  // Function.prototype.newApply = function(obj, arr) {
  //   // console.log(arguments);
  //   obj = obj || window;
  //   obj.fn = this;
  //   let result;
  //   if (arr) {
  //     result = obj.fn(...arr);
  //   } else {
  //     result = obj.fn();
  //   }
  //   delete obj.fn;
  //   return result;
  // }
```

* bind

```js
Function.prototype.newBind = function (obj, ...agrs) {
    let fn = this;
   // let args = [...arguments].slice(1);
    return function() {
      if (new.target !== undefined) {
        return new fn(...args, ...arguments);
      }
      return fn.call(obj, ...agrs, ...arguments);
    }
```



https://blog.csdn.net/m0_52409770/article/details/123484053

## 数组扁平化

```js
  const arr = [1, [2, 3, [4, 5]]];
  let result = [];
  function flat(arr) {
    let res = [];
    function traverse(arr) {
      arr.forEach(element => {
        if (Array.isArray(element)) traverse(element);
        else res.push(element);
      });
    }
    traverse(arr);
    return res;
  }
  console.log(flat(arr));


   function flat(arr, n) {
    let res = [];
    function traverse(arr, n) {
      arr.forEach(element => {
        if (Array.isArray(element) && n != 0) traverse(element, --n);
        else res.push(element);
      });
    }
    traverse(arr, n);
    return res;
  }

  
  console.log(flat(arr,2));
```

## 函数柯里化

接受一些参数，**接受了这些参数之后，该函数并不会立即求值，而是继续返回另外一个函数，刚才传入的参数在函数形成的闭包中被保存起来**。待到函数被**真正需要求值的时候，之前传入的所有参数都会被一次性用于求值**。

```js
  function add() {
    let args = [...arguments];
    let inner = function() {
      args.push(...arguments);
      return inner;
    }
    inner.toString = function (){
      return args.reduce((pre, cur) => pre + cur, 0);
    }
    return inner;
  }

  console.log(add(1)(2)(3) == 6) // 6;
  console.log(add(1, 2, 3)(4) == 10) // 10;
  console.log(add(1)(2)(3)(4)(5) == 15) // 15;
```

## 函数式编程

纯函数属于程序设计的名词，其它语言中也是存在的，而在javascript中，符合以下规则即为纯函数。

- 函数有相同的输入，必定有相同的输出
- 函数的输出仅与输入有关，与其他隐藏信息无关
- 不得产生任何的副作用，如 触发事件修改全局变量、修改参数或者改变外部存储等

## 函数参数是按照什么方式传递的

1、函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）。这意味着，在函数体内修改参数值，不会影响到函数外部。

2、如果函数参数是引用的值（数组、对象、其他函数），传递方式是传址（引用）传递（pass by reference）。也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值。

3、注意，如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值。这是因为，形式参数（`o`）的值实际是参数`obj`的地址，重新对`o`赋值导致`o`指向另一个地址，保存在原地址上的值当然不受影响。

## prototype属性的作用

JavaScript 继承机制的设计思想就是，**原型对象的所有属性和方法，都能被实例对象共享**。也就是说，如果属性和方法定义在原型上，那么所有实例对象就能共享，不仅节省了内存，还体现了实例对象之间的联系。当实例对象本身没有某个属性或方法的时候，它会到原型对象去寻找该属性或方法。如果对象自身和它的原型，都定义了一个同名属性，那么优先读取对象自身的属性，这叫做“覆盖”（overriding）。

## 原型链

1. 原型可以解决什么问题
    对象共享属性和共享方法
2. 对象查找属性或者方法的顺序
    先在对象本身查找 --> 构造函数中查找 --> 对象的原型 --> 构造函数的原型中 --> 当前原型的原型中查找

①所有`引用类型`都有一个`__proto__(隐式原型)`属性，属性值是一个普通的对象
②所有`函数`都有一个`prototype(原型)`属性，属性值是一个普通的对象
③所有`引用类型的__proto__`属性`指向`它`构造函数的prototype`

JavaScript 规定，所有对象都有自己的原型对象（prototype）。一方面，任何一个对象，都可以充当其他对象的原型；另一方面，由于原型对象也是对象，所以它也有自己的原型。因此，就会形成一个“原型链”（prototype chain）：对象到原型，再到原型的原型。

如果一层层地上溯，所有对象的原型最终都可以上溯到`Object.prototype`，即`Object`构造函数的`prototype`属性。也就是说，所有对象都继承了`Object.prototype`的属性。这就是所有对象都有`valueOf`和`toString`方法的原因，因为这是从`Object.prototype`继承的。

那么，`Object.prototype`对象有没有它的原型呢？回答是`Object.prototype`的原型是`null`。`null`没有任何属性和方法，也没有自己的原型。因此，原型链的尽头就是`null`。

![image-20220708090958140](C:\Users\YangXuanhao\AppData\Roaming\Typora\typora-user-images\image-20220708090958140.png)

## 6种继承

继承：子对象可以使用父对象上所有的方法和属性

**方式1 原型链继承**
核⼼：**将⽗类实例作为⼦类构造函数的原型**
优点：⽅法复⽤
	由于⽅法定义在⽗类的原型上，复⽤了⽗类构造函数的⽅法。⽐如say⽅法。
缺点：
	创建⼦类实例的时候，不能传⽗类的参数（⽐如name）。
	⼦类实例共享了⽗类构造函数的引⽤属性，⽐如arr属性。
	⽆法实现多继承。

````js
function Parent(name) {
this.name = name || '⽗亲'; // 实例基本属性 (该属性，强调私有，不共享)
this.arr = [1]; // (该属性，强调私有)
}
Parent.prototype.say = function() { // -- 将需要复⽤、共享的⽅法定义在⽗类原型上
console.log('hello')
}
function Child(like) {
this.like = like;
}
Child.prototype = new Parent() // 核⼼，但此时Child.prototype.constructor==Parent
Child.prototype.constructor = Child // 修正constructor指向
let boy1 = new Child()
let boy2 = new Child()
// 优点：共享了⽗类构造函数的say⽅法
console.log(boy1.say(), boy2.say(), boy1.say === boy2.say); // hello , hello , true
// 缺点1：不能向⽗类构造函数传参
console.log(boy1.name, boy2.name, boy1.name===boy2.name); // ⽗亲，⽗亲，true
// 缺点2: ⼦类实例共享了⽗类构造函数的引⽤属性，⽐如arr属性
boy1.arr.push(2);
// 修改了boy1的arr属性，boy2的arr属性，也会变化，因为两个实例的原型上(Child.prototype)有了⽗类构造函数的实例属性arr；
所以只要修改了boy1.arr，boy2.arr的属性也会变化。
console.log(boy2.arr); // [1,2]
注意1：修改boy1的name属性，是不会影响到boy2.name。因为设置boy1.name相当于在⼦类实例新增了name属性。
注意2：
console.log(boy1.constructor); // Parent 你会发现实例的构造函数居然是Parent。
⽽实际上，我们希望⼦类实例的构造函数是Child,所以要记得修复构造函数指向。
修复如下：Child.prototype.constructor = Child;
````

其实Child.prototype = new Parent()表示
`console.log(Child.prototype.__proto__ === Parent.prototype)`; // true
因为Child.prototype等于Parent的实例，所以`__proto__`指向Parent.prototype

**方式2 借用构造函数**

核⼼：**借⽤⽗类的构造函数来增强⼦类实例，等于是复制⽗类的实例属性给⼦类。**
优点：实例之间独⽴。
	创建⼦类实例，可以向⽗类构造函数传参数。
	⼦类实例不共享⽗类构造函数的引⽤属性。如arr属性
	可实现多继承（通过多个call或者apply继承多个⽗类）
缺点：
	⽗类的⽅法不能复⽤
		由于⽅法在⽗构造函数中定义，导致⽅法不能复⽤(因为每次创建⼦类实例都要创建⼀遍⽅法)。
		⽐如say⽅法。(⽅法应该要复⽤、共享)
	⼦类实例，继承不了⽗类原型上的属性。(因为没有⽤到原型)

```js
function Parent(name) {
this.name = name; // 实例基本属性 (该属性，强调私有，不共享)
this.arr = [1]; // (该属性，强调私有)
this.say = function() { // 实例引⽤属性 (该属性，强调复⽤，需要共享)
console.log('hello')
}
}
function Child(name,like) {
Parent.call(this,name); // 核⼼ 拷⻉了⽗类的实例属性和⽅法
this.like = like;
}
let boy1 = new Child('⼩红','apple');
let boy2 = new Child('⼩明', 'orange ');
// 优点1：可向⽗类构造函数传参
console.log(boy1.name, boy2.name); // ⼩红， ⼩明
// 优点2：不共享⽗类构造函数的引⽤属性
boy1.arr.push(2);
console.log(boy1.arr,boy2.arr);// [1,2] [1]
// 缺点1：⽅法不能复⽤
console.log(boy1.say === boy2.say) // false (说明，boy1和boy2的say⽅法是独⽴，不是共享的)
// 缺点2：不能继承⽗类原型上的⽅法
Parent.prototype.walk = function () { // 在⽗类的原型对象上定义⼀个walk⽅法。
console.log('我会⾛路')
}
boy1.walk; // undefined (说明实例，不能获得⽗类原型上的⽅法)
```

**方式3 组合继承**

核⼼：通过**调⽤⽗类构造函数，继承⽗类的属性**并保留传参的优点；然后通过将**⽗类实例作为
⼦类原型，实现函数复⽤**。
优点：
	保留构造函数的优点：创建⼦类实例，可以向⽗类构造函数传参数。
	保留原型链的优点：⽗类的⽅法定义在⽗类的原型对象上，可以实现⽅法复⽤。
	不共享⽗类的引⽤属性。⽐如arr属性
缺点：
	由于调⽤了2次⽗类的构造⽅法，会存在⼀份多余的⽗类实例属性，具体原因⻅⽂末。
注意：'组合继承'这种⽅式，要记得修复Child.prototype.constructor指向
第⼀次Parent.call(this);从⽗类拷⻉⼀份⽗类实例属性，作为⼦类的实例属性，第⼆次Child.prototype = new Parent();创建⽗类实例作为⼦类原型，Child.prototype中的⽗类属性和⽅法会被第⼀次拷⻉来的实例属性屏蔽掉，所以多余。

```js
function Parent(name) {
this.name = name; // 实例基本属性 (该属性，强调私有，不共享)
this.arr = [1]; // (该属性，强调私有)
}
Parent.prototype.say = function() { // --- 将需要复⽤、共享的⽅法定义在⽗类原型上
console.log('hello')
}
function Child(name,like) {
Parent.call(this,name,like) // 核⼼ 第⼆次
this.like = like;
}
Child.prototype = new Parent() // 核⼼ 第⼀次
Child.prototype.constructor = Child // 修正constructor指向
let boy1 = new Child('⼩红','apple')
let boy2 = new Child('⼩明','orange')
// 优点1：可以向⽗类构造函数传参数
console.log(boy1.name,boy1.like); // ⼩红，apple
// 优点2：可复⽤⽗类原型上的⽅法
console.log(boy1.say === boy2.say) // true
// 优点3：不共享⽗类的引⽤属性，如arr属性
boy1.arr.push(2)
console.log(boy1.arr,boy2.arr); // [1,2] [1] 可以看出没有共享arr属性。
// 缺点1：由于调⽤了2次⽗类的构造⽅法，会存在⼀份多余的⽗类实例属性
```



**方式4 原型式继承**

Object.create()⽅法创建⼀个新对象，使⽤第⼀个参数来提供新创建对象的`__proto__`（以第⼀个参 数作为新对象的构造函数的原型对象）； ⽅法还有第⼆个可选参数，是添加到新创建对象的属性。

```js
 let parent4 = {
    name: "parent4",
    friends: ["p1", "p2", "p3"],
    getName: function() {
      return this.name;
    }
  };
 
  let person4 = Object.create(parent4);
  person4.name = "tom";
  person4.friends.push("jerry");
  let person5 = Object.create(parent4);
  person5.friends.push("lucy");
 
  console.log(person4.name); //tom
  console.log(person4.name === person4.getName()); //true
  console.log(person5.name); //parent4
  console.log(person4.friends);// ["p1","p2","p3","jerrry","lucy"]
  console.log(person5.friends);// ["p1","p2","p3","jerrry","lucy"]
```

**方式5 组合继承优化1**

核⼼：
通过这种⽅式，砍掉⽗类的实例属性，这样在调⽤⽗类的构造函数的时候，就不会初始化两次实
例，避免组合继承的缺点。
优点：
	只调⽤⼀次⽗类构造函数。
	保留构造函数的优点：创建⼦类实例，可以向⽗类构造函数传参数。
	保留原型链的优点：⽗类的实例⽅法定义在⽗类的原型对象上，可以实现⽅法复⽤。
缺点：
	修正构造函数的指向之后，⽗类实例的构造函数指向，同时也发⽣变化(这是我们不希望的)
注意：'组合继承优化1'这种⽅式，要记得修复Child.prototype.constructor指向
原因是：不能判断⼦类实例的直接构造函数，到底是⼦类构造函数还是⽗类构造函数。

```js
function Parent(name) {
this.name = name; // 实例基本属性 (该属性，强调私有，不共享)
this.arr = [1]; // (该属性，强调私有)
}
Parent.prototype.say = function() { // --- 将需要复⽤、共享的⽅法定义在⽗类原型上
console.log('hello')
}
function Child(name,like) {
Parent.call(this,name,like) // 核⼼
this.like = like;
}
Child.prototype = Parent.prototype // 核⼼ ⼦类原型和⽗类原型，实质上是同⼀个
<!--这⾥是修复构造函数指向的代码-->
Child.prototype.constructor = Child
let boy1 = new Child('⼩红','apple')
let boy2 = new Child('⼩明','orange')
let p1 = new Parent('⼩爸爸')
// 优点1：可以向⽗类构造函数传参数
console.log(boy1.name,boy1.like); // ⼩红，apple
// 优点2：可复⽤⽗类原型上的⽅法
console.log(boy1.say === boy2.say) // true
// 缺点1：当修复⼦类构造函数的指向后，⽗类实例的构造函数指向也会跟着变了。
没修复之前：console.log(boy1.constructor); // Parent
修复代码：Child.prototype.constructor = Child
修复之后：console.log(boy1.constructor); // Child
console.log(p1.constructor);// Child 这⾥就是存在的问题(我们希望是Parent)
具体原因：因为是通过原型来实现继承的，Child.prototype的上⾯是没有constructor属性的，
就会往上找，这样就找到了Parent.prototype上⾯的constructor属性；当你修改了⼦类实例的
construtor属性，所有的constructor的指向都会发⽣变化。
```

**方式6 寄生组合继承 --- 完美方式**

```js
function Parent(name) {
this.name = name; // 实例基本属性 (该属性，强调私有，不共享)
this.arr = [1]; // (该属性，强调私有)
}
Parent.prototype.say = function() { // --- 将需要复⽤、共享的⽅法定义在⽗类原型上
console.log('hello')
}
function Child(name,like) {
Parent.call(this,name,like) // 核⼼
this.like = like;
}
// 核⼼ 通过创建中间对象，⼦类原型和⽗类原型，就会隔离开。不是同⼀个啦，有效避免了⽅式4的缺点。
Child.prototype = Object.create(Parent.prototype);
// 这⾥是修复构造函数指向的代码
Child.prototype.constructor = Child
let boy1 = new Child('⼩红','apple')
let boy2 = new Child('⼩明','orange')
let p1 = new Parent('⼩爸爸')
注意：这种⽅法也要修复构造函数的
修复代码：Child.prototype.constructor = Child
修复之后：console.log(boy1.constructor); // Child
console.log(p1.constructor); // Parent 完美😊
```

**方式7 ES6 class extends继承**

```js
class Parent{
	constructor(){
		this.age = 18;
	}
}

class Child extends Parent{
	constructor(){
		super();
		this.name = '张三';
	}
}
let o1 = new Child();
console.log( o1,o1.name,o1.age );
```



## 任务队列和事件循环

JavaScript引擎是单线程，也就是说每次只能执行一项任务，其他任务都得按照顺序排队等待被执行，只有当前的任务执行完成之后才会执行下一个任务。

Javascript单线程任务被分为**同步任务**和**异步任务**。

同步任务：立即执行的任务，在主线程上排队执行，前一个任务执行完毕，才能执行后一个任务；异步任务：异步执行的任务，不进入主线程， 而是在异步任务有了结果后，将注册的回调函数放入任务队列中等待主线程空闲的时候读取执行。注意：异步函数在相应辅助线程中处理完成后，即异步函数达到触发条件了，就把回调函数推入任务队列中，而不是说注册一个异步任务就会被放在这个任务队列中

![img](https://pics5.baidu.com/feed/e7cd7b899e510fb390868fc632f2479dd0430c0a.png?token=712ee8e515a382162c7e0c4ad4329559)

从上面流程图中可以看到，主线程不断从任务队列中读取事件，这个过程是循环不断的，这种运行机制就叫做Event Loop

执行过程：

1.先执行所有同步任务，碰到异步任务放到任务队列中

2.同步任务执行完毕，开始执行当前所有的异步任务

3.先执行任务队列里面所有的微任务

4.然后执行一个宏任务

5.然后再执行所有的微任务

6.再执行一个宏任务，再执行所有的微任务·······依次类推到执行结束。

3-6的这个循环称为事件循环Event Loop

## 宏任务和微任务

事件循环中并非只维护着一个队列，实际上是两个队列

宏任务队列：ajax、setTimeout、setinterval、DOM监听、UI Rendering等
微任务队列：Promise的then回调、process.nextTick、Mutation Observe API、queueMicrotask
两个队列的优先级

所有同步任务都在主线程上执行，形成一个执行栈
主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件
一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行
在执行任何一个宏任务以前（不是队列，是一个宏任务）,都会查看微任务队列是否有任务需要清空，也就是宏任务执行以前，必须保证微任务是空的
主线程不断重复上面的步骤

每次单个**宏任务**执行完毕后， 检查**微任务**队列是否为空， 如果不为空，会按照**先入先出**的规则全部执行完**微任务**后， 清空微任务队列， 然后再执行下一个**宏任务**，如此循环

## 防抖

用户事件触发过于频繁，只要最后一次。

当事件触发事件时，一定时间段`t`内没有再次触发事件，事件处理函数才会执行，如果在时间段`t`内，又触发了一次函数，就重新开始延时，即再过`t`时间后执行。

防抖的关键在于，在一个**动作发生** 一定时间之后，才执行**特定的事件**。

```js
  function debounce(fn, delay) {
    let timer;
    return function () {
      if (timer) clearTimeout(timer);
      timer = setTimeout(() => {
        fn.apply(this, arguments);
      }, delay);
    }
  }
```

## 节流

控制高频事件执行次数。

当持续触发事件时，保证一定时间段`t`内只调用一次事件处理函数。

侧重于一段时间内，执行一次。

```js
  function throttle(fn, delay) {
    let timer;
    return function() {
      if (timer) return;
      timer = setTimeout(() => {
        fn.apply(this, arguments);  
        clearTimeout(timer);
        timer = null;
      }, delay);
    }
  }
```



## JavaScript 有三种方法，可以为事件绑定监听函数

第一种“HTML 的 on- 属性”，违反了 HTML 与 JavaScript 代码相分离的原则，将两者写在一起，不利于代码分工，因此不推荐使用。

第二种“元素节点的事件属性”的缺点在于，同一个事件只能定义一个监听函数，也就是说，如果定义两次`onclick`属性，后一次定义会覆盖前一次。因此，也不推荐使用。

第三种`EventTarget.addEventListener`是推荐的指定监听函数的方法。它有如下优点：

- 同一个事件可以**添加多个监听函数**。
- 能够**指定在哪个阶段**（捕获阶段还是冒泡阶段）触发监听函数。
- 除了 DOM 节点，其他对象（比如`window`、`XMLHttpRequest`等）也有这个接口，它等于是**整个 JavaScript 统一的监听函数接口**。

## 介绍一下promise

Promise 是一个对象，保存着未来将要结束的事件，它有两个特征: 

1、对象的状态不受外部影响，Promise 对象代表一个异步操作，有三种状态，pending 进行中，fulfilled 已成功，rejected 已失败，只有异步操作的结果，才可以决定当前是哪 一种状态，任何其他操作都无法改变这个状态，这也就是 promise 名字的由来 

2、一旦状态改变，就不会再变，promise 对象状态改变只有两种可能，从 pending 改到 fulfilled 或者从 pending 改到 rejected，只要这两种情况发生，状态就凝固了，不会再改变，这个时候就称为定型 resolve

**Promise.all()**

`p`的状态由`p1`、`p2`、`p3`决定，分成两种情况。

（1）只有`p1`、`p2`、`p3`的状态都变成`fulfilled`，`p`的状态才会变成`fulfilled`，此时`p1`、`p2`、`p3`的返回值组成一个数组，传递给`p`的回调函数。

（2）只要`p1`、`p2`、`p3`之中有一个被`rejected`，`p`的状态就变成`rejected`，此时第一个被`reject`的实例的返回值，会传递给`p`的回调函数。

**Promise.race()**

上面代码中，只要`p1`、`p2`、`p3`之中有一个实例率先改变状态，`p`的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给`p`的回调函数。

**Promise.allSettled()**

`Promise.allSettled()`方法接受一个数组作为参数，数组的每个成员都是一个 Promise 对象，并返回一个新的 Promise 对象。只有等到参数数组的所有 Promise 对象都发生状态变更（不管是`fulfilled`还是`rejected`），返回的 Promise 对象才会发生状态变更。

```js
const resolved = Promise.resolve(42);
const rejected = Promise.reject(-1);

const allSettledPromise = Promise.allSettled([resolved, rejected]);

allSettledPromise.then(function (results) {
  console.log(results);
});
// [
//    { status: 'fulfilled', value: 42 },
//    { status: 'rejected', reason: -1 }
// ]
```

**Promise.any()**

只要参数实例有一个变成`fulfilled`状态，包装实例就会变成`fulfilled`状态；如果所有参数实例都变成`rejected`状态，包装实例就会变成`rejected`状态。

`Promise.any()`跟`Promise.race()`方法很像，只有一点不同，就是`Promise.any()`不会因为某个 Promise 变成`rejected`状态而结束，必须等到所有参数 Promise 变成`rejected`状态才会结束。

##  事件的传播（DOM事件流）

一个事件发生后，会在子元素和父元素之间传播（propagation）。这种传播分成三个阶段。

- **第一阶段**：从`window`对象传导到目标节点（上层传到底层），称为“捕获阶段”（capture phase）。
- **第二阶段**：在目标节点上触发，称为“目标阶段”（target phase）。
- **第三阶段**：从目标节点传导回`window`对象（从底层传回上层），称为“冒泡阶段”（bubbling phase）。

事件传播的最上层对象是`window`，接着依次是`document`，`html`（`document.documentElement`）和`body`（`document.body`）。也就是说，上例的事件传播顺序，在捕获阶段依次为`window`、`document`、`html`、`body`、`div`、`p`，在冒泡阶段依次为`p`、`div`、`body`、`html`、`document`、`window`。

##  事件的代理（事件委托，事件委派）

由于事件会在冒泡阶段向上传播到父节点，因此可以**把子节点的监听函数定义在父节点上**，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做**事件的代理**（delegation）。

`click`事件的监听函数定义在`<ul>`节点，但是实际上，它处理的是子节点`<li>`的`click`事件。这样做的好处是，只要定义一个监听函数，就能处理多个子节点的事件，而不用在每个`<li>`节点上定义监听函数。而且以后再添加子节点，监听函数依然有效。

如果希望事件到某个节点为止，不再传播，可以使用事件对象的`stopPropagation`方法。

但是，`stopPropagation`方法只会阻止事件的传播，不会阻止该事件触发`<p>`节点的其他`click`事件的监听函数。也就是说，不是彻底取消`click`事件。如果想要彻底取消该事件，不再触发后面所有`click`的监听函数，可以使用`stopImmediatePropagation`方法。

##  浅拷贝和深拷贝

**浅拷贝就是指对象复制的时候只复制一层；深拷贝是指复制对象的所有层级。**

对于JavaScript数组等复杂的数据类型来说，将其赋值给其它变量，其实只是复制了对象的地址给它，两个变量指向的是同一个对象，因此普通的赋值既不是深拷贝也不是浅拷贝。

在浅拷贝时，拷贝出来的新对象的地址和原对象是不一样的，但是新对象里面的可变元素（如列表）的地址和原对象里的可变元素的地址是相同的，也就是说浅拷贝它拷贝的是浅层次的数据结构（不可变元素），对象里的可变元素作为深层次的数据结构并没有被拷贝到新地址里面去。

而是和原对象里的可变元素指向同一个地址，所以在新对象或原对象里对这个可变元素做修改时，两个对象是同时改变的，但是深拷贝不会这样，这个是浅拷贝相对于深拷贝最根本的区别。

##  JavaScript 代码嵌入网页的方法

网页中嵌入 JavaScript 代码，主要有四种方法。

- `<script>`元素直接嵌入代码。
- `<script>`标签加载外部脚本 src属性
- 事件属性  这种方式一般以“JavaScript: XXXXX”的格式出现，后面直接跟js代码。

##  script标签写在head标签中会有什么问题？怎么解决？

因为在 DOM 结构生成之前就调用 DOM 节点，JavaScript 会报错，如果脚本都在网页尾部加载，就不存在这个问题，因为这时 DOM 肯定已经生成了。

* 一种解决方法是设定`DOMContentLoaded`事件的回调函数。

```js
<head>
  <script>
    document.addEventListener(
      'DOMContentLoaded',
      function (event) {
        console.log(document.body.innerHTML);
      }
    );
  </script>
</head>
```

* 另一种解决方法是，使用`<script>`标签的`onload`属性。当`<script>`标签指定的外部脚本文件下载和解析完成，会触发一个`load`事件，可以把所需执行的代码，放在这个事件的回调函数里面。

```
<script src="jquery.min.js" onload="console.log(document.body.innerHTML)">
</script>
```

* window.onload  = function() {}

**window.onload** 方法用于在网页加载完毕后立刻执行的操作，即当 HTML 文档加载完毕后，立刻执行某个方法。

##  前端优化

* 对于来自同一个域名的资源，比如脚本文件、样式表文件、图片文件等，浏览器一般有限制，同时最多下载6～20个资源，即最多同时打开的 TCP 连接有限制，这是为了防止对服务器造成太大压力。如果是来自不同域名的资源，就没有这个限制。所以，**通常把静态文件放在不同的域名之下，以加快下载速度**。（<script>标签不存在跨域问题）
* 大多数情况下，浏览器会智能判断，将重流和重绘只限制到相关的子树上面，最小化所耗费的代价，而不会全局重新生成网页。作为开发者，应该**尽量设法降低重绘的次数和成本**。比如，尽量不要变动高层的 DOM 元素，而以底层 DOM 元素的变动代替；再比如，重绘`table`布局和`flex`布局，开销都会比较大。
* 下面是一些优化技巧。
  - 读取 DOM 或者写入 DOM，尽量写在一起，不要混杂。不要读取一个 DOM 节点，然后立刻写入，接着再读取一个 DOM 节点。
  - 缓存 DOM 信息。
  - 不要一项一项地改变样式，而是使用 CSS class 一次性改变样式。
  - 使用`documentFragment`操作 DOM
  - 动画使用`absolute`定位或`fixed`定位，这样可以减少对其他元素的影响。
  - 只在必要时才显示隐藏元素。
  - 使用`window.requestAnimationFrame()`，因为它可以把代码推迟到下一次重绘之前执行，而不是立即要求页面重绘。
  - 使用虚拟 DOM（virtual DOM）库。
* `window.requestIdleCallback()`跟`setTimeout`类似，也是将某个函数推迟执行，但是它保证将回调函数推迟到系统资源空闲时执行。也就是说，如果某个任务不是很关键，就可以使用`window.requestIdleCallback()`将其推迟执行，以保证网页性能。

## CRP性能优化

https://www.cnblogs.com/zhimao/p/15068536.html

**前端性能优化核心处理思想: CRP**

**CRP: Critical Rendering Path, 关键路径渲染, 就是了解浏览器渲染的每个环节, 然后针对每个环节进行优化**

因此可以通过分析我们输入url并敲回车以后发生的具体细节来进行优化

1. 使用缓存

2. DNS预解析

3. 减少HTTP请求次数和大小

4. 图片资源的优化

5. CDN加速

6. 服务端开启GZIP压缩HTTP响应包

7. css样式放在顶部, js脚本放在底部

8. 优化JS代码

9. DOM层面优化
	1. 减少重排和重绘

    2. 使用事件委托

    3. 使用防抖和节流函数

    4. requestAnimationFrame 和 cancelAnimationFrame


## cookie、session、token的区别

* Cookie 是服务器保存在**浏览器的一小段文本信息**，一般大小不能超过**4KB**。浏览器每次向服务器发出请求，就会自动附上这段信息。

HTTP 协议不带有状态，有些请求需要区分状态，就通过 Cookie 附带字符串，让服务器返回不一样的回应。举例来说，用户登录以后，服务器往往会在网站上留下一个 Cookie，记录用户编号（比如`id=1234`），以后每次浏览器向服务器请求数据，就会带上这个字符串，服务器从而知道是谁在请求，应该回应什么内容。每次都会携带在 header 中，对于请求性能影响。

* session 是另一种记录服务器和客户端会话状态的机制；**session 存储在服务器端**，一般是文件中，也可以存在数据库或缓存中。session 一般基于 cookie 实现。session 中包含敏感信息存储在服务器端，通常将 sessionId 存储在客户端的 cookie 中，客户端每次请求携带 sessionId 即可识别用户。随着访问服务器的用户数量的增多，服务器上保存的Session也日益增多，这对服务器来说是个巨大的开销，对于单个服务器的Web应用汇总，大量的Session会占用比较多的内存。



* token 是验证用户身份的凭证，我们通常叫它：令牌。

最简单的token组成: uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，以哈希算法压缩成一定长的十六进制字符串）

token在服务器端生成一个字符串，作为客户端请求数据的令牌，用户第一次登录以后，就会产生一个token字符串，并且把这个字符串返回给客户端，后面再请求的时候，只要带上这个token来就行了，不需要再带上用户名和密码，服务器不需要记录任何东西，每次都是一个无状态的请求，每次都是通过**解密来验证**是否合法。

https://www.cnblogs.com/fighter007/p/14225071.html

HTTP请求是无状态的，就是说第一次和服务器连接并登陆成功后，第二次请求服务器仍然不知道当前请求的用户。Cookie出现就是解决了这个问题，第一次登陆后服务器返回一些数据(cookie)给浏览器，然后浏览器保存在本地，当用户第二次返回请求的时候，就会把上次请求存储的cookie数据自动携带给服务器。

## 什么是浏览器缓存

浏览器缓存(Brower Caching)是浏览器在本地磁盘对用户最近请求过的文档进行存储，当访问者再次访问同一页面时，浏览器就可以直接从本地磁盘加载文档。

浏览器在加载资源时，根据请求头的Expires 和 Cache-control 判断是否命中强缓存，是则直接从缓存读取资源，不会发请求到服务器。

如果没有命中强缓存，浏览器一定会发送一个请求到服务器，通过 Last-Modified 和 Etag 验证资源是否命中协商缓存，如果命中，服务器会将这个请求返回，但是不会返回这个资源的数据，依然是从缓存中读取资源。

如果前面两者都没有命中，直接从服务器加载资源。

## 强缓存和协商缓存

浏览器缓存主要有两类：协商缓存和强缓存

1.强缓存：不会向服务器发送请求，直接从缓存中读取资源，状态码是200;

2.协商缓存：向服务器发送请求，服务器会根据这个请求的Request headers的一些参数来判断是否命中协商缓存，如果命中，从缓存中读取数据，返回304状态码

两者共同点：都是从客户端缓存中读取资源；

区别：强缓存不会发请求，协商缓存会发请求。

强制缓存（客户端在xxx秒的有效期内，如果又请求该资源，就直接读取缓存）
Expires：值为绝对时间，不过Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1

Cache-Control：值为相对时间，如果与Expires同时设置的话，其优先级高于Expires。

cache-control有下面几个比较常用的设置值：

-max-age：设置失效时间，客户端在这个有效期内，如果又请求该资源，就直接读取缓存

-no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则从缓存中取数据

-no-store：直接禁止浏览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求。

-public：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。

-private：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。

协商缓存
**Last-Modify搭配If-Modify-Since**：浏览器第一次请求一个资源的时候，服务器返回的header中会加上Last-Modify，Last-modify是该资源的最后修改时间；当浏览器再次请求该资源时，request的请求头中会包含If-Modify-Since，该值服务端header中返回的Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存

**Etag搭配If-None-Match**：web服务器响应请求时，会在header中加一个Etag用来告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。则再次向web服务器请求时带上头If-None-Match （Etag的值）。web服务器收到请求后将If-None-Match与Etag进行比对，决定是否命中协商缓存；

ETag和Last-Modified的作用和用法，他们的区别：

1.Etag要优于Last-Modified。Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；

2.在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值；

3.在优先级上，服务器校验优先考虑Etag。

## 浏览器缓存过程

1.浏览器第一次请求资源，服务器返回200，并把资源上次修改时间Last-Modify和资源的唯一标识Etag写在response header中，浏览器将资源文件从服务器上请求下载下来，

2.下一次请求，先比较当前时间和上一次返回200时的时间差，如果没有超过cache-control设置的max-age，则没有过期，命中强缓存，不发请求直接从本地缓存读取该文件（如果浏览器不支持HTTP1.1，则用expires判断是否过期）；如果时间过期，则向服务器发送header带有If-None-Match和If-Modified-Since的请求

3.服务器收到请求后，优先根据Etag的值判断被请求的文件有没有做修改，Etag值一致则没有修改，命中协商缓存，返回304；如果不一致则有改动，直接返回新的资源文件带上新的Etag值并返回200；

4.如果服务器收到的请求没有Etag值，则将If-Modified-Since和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回304；不一致则返回新的last-modified和文件并返回200；

## CDN加速？

CDN (全称 Content Delivery Network)，即**内容分发网络**

构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN 的关键技术主要有内容存储和分发技术

简单来讲，**CDN就是根据用户位置分配最近的资源**

于是，用户在上网的时候不用直接访问源站，而是访问离他“最近的”一个 CDN 节点，术语叫「边缘节点」，其实就是缓存了源站内容的代理服务器。



## AJAX

AJAX 通过原生的`XMLHttpRequest`对象发出 HTTP 请求，得到服务器返回的数据后，再进行处理。现在，服务器返回的都是 JSON 格式的数据，XML 格式已经过时了，但是 AJAX 这个名字已经成了一个通用名词，字面含义已经消失了。

一旦拿到服务器返回的数据，**AJAX 不会刷新整个网页，而是只更新网页里面的相关部分，从而不打断用户正在做的事情**。

注意，AJAX 只能向同源网址（协议、域名、端口都相同）发出 HTTP 请求，如果发出跨域请求，就会报错。

## 跨页面通信

https://blog.csdn.net/qq_38211888/article/details/121498124

1. 对于同源页面，常见的方式包括：

   - 广播模式：Broadcast Channel / Service Worker / LocalStorage + StorageEvent
   - 共享存储模式：Shared Worker / IndexedDB / cookie 轮询
   - 口口相传模式：window.open + window.opener
   - 基于服务端：Websocket / Comet / SSE 等

   而对于非同源页面，则可以通过嵌入同源 iframe 作为“桥”，将非同源页面通信转换为同源页面通信。

## 浏览器同源策略，跨域问题

* https://blog.csdn.net/qq_42349528/article/details/123074877
* 同源

同源政策的**目的**，**是为了保证用户信息的安全，防止恶意的网站窃取数据**。

如果非同源，共有三种行为受到限制。

> （1） 无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB。
>
> （2） 无法接触非同源网页的 DOM。
>
> （3） 无法向非同源地址发送 AJAX 请求（可以发送，但浏览器会拒绝接受响应）。

同源政策规定，AJAX 请求只能发给同源的网址，否则就报错。

## 如何解决跨域问题

1. JSONP

   * JSONP的本质是，利用**script标签的src属性不受同源策略的影响**，通过带有**参数和回调函数的url发起一次get请求**（这也是jsonp只能发起get请求的原因，因为只有get请求才能把参数和回调函数拼接到url中），服务器将**接口返回的数据拼凑到回调函数**中，返回给浏览器，浏览器**解析执行**，从而前端**拿到回调函数返回的数据**。

     **前端代码**：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>jsonp跨域</title>
</head>
<body>
    <script>
        function fn(data) {
            console.log('客户端的fn函数被调用了')
            console.log(data)
        }
    </script>
     <!-- 将非同源服务器端端请求地址写在script标签的src属性中 -->
     <!-- jsonp要在下面的script标签中使用，因为在上面的标签中使用会找不到函数fn -->
    <script src="http://localhost:3001/test?name=admin&callback=fn"></script>
    <!-- jsonp的缺点：1.具有局限性，仅支持get方法  2.不安全，可能会遭受xss攻击 -->
</body>
</html>
```

**后端代码（node）：**

```js
//引入express框架
const express = require('express');
//创建web服务器
const app = express();

app.get('/test',(req,res) => {
    //从req的url中，解析出传递过来的参数和回调函数
    //并把它拼接成result的形式
    var result = 'fn({name:"张三"})'
    res.send(result)
})

//监听端口
app.listen(3001)
//控制台提示输出
console.log('端口为3001的服务器启动成功！')
```

2. CORS

   * 定义：跨域资源共享（Cross Origin Resource Sharing, CORS）是一种机制，它使用额外的HTTP头来告诉浏览器，让运行在一个origin（domain）上的Web应用被准许访问来自不同源服务器上的指定资源。当一个资源从该资源本身所在的服务器不同的域，协议或端口请求一个资源时，资源会发起一个跨域HTTP请求。实现CORS的关键是服务器，**只要服务器实现了CORS请求，就可以跨源通信了**。

     **CORS的实现方式**很简单，当使用XMLHttpRequest发送请求时，浏览器发现该请求不符合同源策略，会给该请求加一个请求头：Origin，后台进行一系列处理，如果确定接收请求则在返回结果中加入一个**响应头：Access-Control-Allow-Origin**;浏览器判断响应头中是否包含Origin的值，如果有则浏览器会处理响应，我们就可以拿到响应数据，如果不包含浏览器直接驳回，这时我们无法拿到响应数据。所以CORS的表象是让你觉得它与同源的ajax请求没啥区别，代码完全一样。

3. WebSocket

   - WebSocket 是一种通信协议，使用`ws://`（非加密）和`wss://`（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。

4. 架设服务器代理（浏览器请求同源服务器，再由后者请求外部服务）

   * ngnix代理跨域
   * 跨域问题：同源策略仅是针对浏览器的安全策略。服务器端调用HTTP接口只是使用HTTP协议，不需要同源策略，也就不存在跨域问题。
     实现思路：通过Nginx配置一个代理服务器域名与domain1相同，端口不同做跳板机，反向代理访问domain2接口，并且顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域访问。
   * **`nginx.conf`具体配置**：

   ```
   #proxy服务器
   server {
   	listen 81;
   	server_name www.domain1.com
   	location / {
   		#反向代理
   		proxy_pass http://www.domain2.com:8080; 
   		 #修改cookie里域名
   		proxy_cookie_domain www.domain2.com www.domain1.com;
   		index index.html index.htm;
   		# 当用webpack-dev-server等中间件代理接口访问nginx时
   		# 此时无浏览器参与，故没有同源限制，下面的跨域配置不可启用
   		# 当前端只跨域不带cookie时，可为*
   		add_header Access-Control-Allow-Origin http://www.domain1.com
   		add_header Access-Control-Allow-Credentials true;
   		}
   }
   ```

## 正向代理和反向代理的区别

**正向代理：**
客户端想要获得一个服务器的数据，但是因为种种原因无法直接获取。于是客户端设置了一个代理服务器，并且指向目标服务器，之后代理服务器像目标服务器转交请求并将获得的内容发送给客户端。这样本质上起到了对真实服务器隐藏真实客户端的目的。实现正向代理需要修改客户端，比如浏览器的配置。

![在这里插入图片描述](https://img-blog.csdnimg.cn/be8c0b17be4b46d8930afb86dd824718.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNDIzNDk1Mjg=,size_20,color_FFFFFF,t_70,g_se,x_16)

**反向代理：**
服务器为了能够将工作负载分布到多个服务器来提高网站性能（负载均衡）等目的，当其受到请求后，会首先根据转发规则来确定请求应该被转发到哪个服务器，然后将请求转发到对应的真实服务器上。这样本质起到了对客户端隐藏真实服务器的作用。
一般使用反向代理后，需要通过修改DNS让域名解析到代理服务器IP，这时浏览器无法察觉到真正服务器的存在，当然也就不需要修改配置了。
**正向代理和反向代理的结构：**
正向代理和反向代理的结构是一样的，都是client-proxy-server的结构，它们主要的区别就在于中间这个proxy是哪一方设置的。在正向代理中，proxy是client设置的，用来隐藏client；而在反向代理中，proxy是server设置的，用来隐藏server.

## 前端存储方式有哪些？cookie、localstorage、sessionstorage区别

![image-20220829202747132](C:\Users\YangXuanhao\AppData\Roaming\Typora\typora-user-images\image-20220829202747132.png)

1、cookies

Cookie 是存储在您计算机上的小型文本文件中的数据。当 Web 服务器将网页发送到浏览器时，连接会关闭，服务器会忘记有关用户的所有信息。发明 Cookie 是为了解决“如何记住用户信息”的问题：

- 当用户访问网页时，他/她的姓名可以存储在 cookie 中。
- 下次用户访问该页面时，cookie 会“记住”他/她的名字。

Cookie 保存在键-值对中，例如：

```text
username = li
```

cookies是HTML5标准前本地储存的主要⽅式，优点是兼容性好，请求头⾃带cookie⽅便，缺点是⼤⼩只有4k， ⾃动请求头加⼊cookie浪费流量，每个domain限制20个cookie，使⽤起来麻烦需要⾃⾏封装。

看你设置的cookie的过期时间是多久了，如果你没设置，则表示这个cookie生命周期为浏览器会话期间，只要关闭浏览器窗口，cookie就消失了。

2、localstorage

localStorage是一种属性，允许 JavaScript 站点和应用程序将键值对保存在 Web 浏览器中，没有过期日期。这意味着即使在浏览器窗口关闭后，存储在浏览器中的数据也会保留。

HTML5加⼊的以键值对(Key-Value)为标准的⽅式，优点是操作⽅便，永久性储存（除⾮⼿动删除），⼤⼩为5M，兼容IE8+。

要`localStorage`在Web [应用程序](https://www.zhihu.com/search?q=应用程序&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2465118941})中使用，有五种方法可供选择：

1. `setItem()`: 添加键和值到`localStorage`
2. `getItem()`: 获取`localStorage`
3. `removeItem()`: 按键删除一个项目`localStorage`
4. `clear()`: 全部清除`localStorage`
5. `key()`: 传递一个数字来检索一个密钥`localStorage` 

使用`localStorage`起来很简单，也很容易误用。以下是限制：

- 不要将敏感的用户信息存储在`localStorage`。
- 它不能替代基于服务器的数据库，因为信息仅存储在浏览器中。
- `localStorage`在所有主要浏览器中限制为 5MB。
- `localStorage`非常不安全，因为它没有任何形式的数据保护，并且可以通过您网页上的任何代码访问。
- `localStorage`是同步的，这意味着调用的每个操作只会一个接一个地执行。

3、sessionstorage

`sessionStorage`仅在浏览器打开时（包括页面重新加载或恢复时）维护一个存储区域，而`localStorage`在浏览器关闭后继续存储数据。换句话说，`sessionStorage`当页面关闭时，存储的数据会被清除，而存储的数据`localStorage`不会过期。

sessionStorage与cookie、 localStorage不同，它**不能在所有同源窗口中共享**，是会话级别的储存⽅式。

4、Web SQL

2010年被W3C废弃的本地数据库数据存储⽅案，但是主流浏览器（⽕狐除外）都已经有了相关的实现，web sql类似于SQLite，是真正意义上的关系型数据库，⽤sql进⾏操作，当我们⽤JavaScript时要进⾏转换， 较为繁琐。 

5、IndexedDB

是被正式纳⼊HTML5标准的数据库储存⽅案，它是NoSQL数据库，⽤键值对进⾏储存，可以进⾏快速读取操作，⾮常适合web场景，同时⽤JavaScript进⾏操作会⾮常⽅便。

**什么情况下适合使用 IndexedDB** 

- 存储大量数据的应用程序
- 不需要持久 Internet 连接仍可工作的应用程序

IndexedDB 可以在浏览器中永久存储数据。无论网络状态如何，都可以查询数据。

## Web Worker

Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务可以交由 Worker 线程执行，主线程（通常负责 UI 交互）能够保持流畅，不会被阻塞或拖慢。

## 网页加载流程

浏览器加载 JavaScript 脚本，主要通过`<script>`元素完成。正常的网页加载流程是这样的。

1. 浏览器一边下载 HTML 网页，一边开始解析。也就是说，不等到下载完，就开始解析。
2. 解析过程中，浏览器发现`<script>`元素，就暂停解析，把网页渲染的控制权转交给 JavaScript 引擎。
3. 如果`<script>`元素引用了外部脚本，就下载该脚本再执行，否则就直接执行代码。
4. JavaScript 引擎执行完毕，控制权交还渲染引擎，恢复往下解析 HTML 网页。

加载外部脚本时，浏览器会暂停页面渲染，等待脚本下载并执行完成后，再继续渲染。原因是 JavaScript 代码可以修改 DOM，所以必须把控制权让给它，否则会导致复杂的线程竞赛的问题。

如果外部脚本加载时间很长（一直无法完成下载），那么浏览器就会一直等待脚本下载完成，造成网页长时间失去响应，浏览器就会呈现“假死”状态，这被称为“阻塞效应”。

为了避免这种情况，较好的做法是将`<script>`标签都放在页面底部，而不是头部。这样即使遇到脚本失去响应，网页主体的渲染也已经完成了，用户至少可以看到内容，而不是面对一张空白的页面。如果某些脚本代码非常重要，一定要放在页面头部的话，最好直接将代码写入页面，而不是连接外部脚本文件，这样能缩短加载时间。

##  浏览器渲染引擎处理网页的流程

渲染引擎处理网页，通常分成四个阶段。

1. 解析代码：HTML 代码解析为 DOM，CSS 代码解析为 CSSOM（CSS Object Model）。
2. 对象合成：将 DOM 和 CSSOM 合成一棵渲染树（render tree）。
3. 布局：计算出渲染树的布局（layout）。
4. 绘制：将渲染树绘制到屏幕。

## 浏览器内部对 JavaScript 的处理过程

1. 读取代码，进行词法分析（Lexical analysis），将代码分解成词元（token）。
2. 对词元进行语法分析（parsing），将代码整理成 抽象语法树(Abstract Syntax Tree,*AST*)。
3. 使用“翻译器”（translator），将代码转为字节码（bytecode）。
4. 使用“字节码解释器”（bytecode interpreter），将字节码转为机器码。

## 页面白屏问题

https://blog.csdn.net/yanhang0227/article/details/106559840?spm=1001.2101.3001.6650.7&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-7-106559840-blog-119769263.pc_relevant_multi_platform_whitelistv1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-7-106559840-blog-119769263.pc_relevant_multi_platform_whitelistv1&utm_relevant_index=13

## 浏览器重绘与重排的区别？

重排: 部分渲染树（或者整个渲染树）需要重新分析并且节点尺⼨需要重新计算，表现为重新⽣成布局，重新排列 元素 

**定义：** 当通过JS或css改变了元素的宽度、高度等，修改了元素的几何位置属性，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫`重排`。无疑， **重排需要更新完整的渲染流水线，所以开销也是最大的。**

重绘: 由于节点的⼏何属性发⽣改变或者由于样式发⽣改变，例如改变元素背景⾊时，屏幕上的部分内容需要更 新，表现为某些元素的外观被改变 单单改变元素的外观，肯定不会引起⽹⻚重新⽣成布局，但当浏览器完成重排之后，将会重新绘制受到此次重排影响的 部分 重排和重绘代价是⾼昂的，它们会破坏⽤户体验，并且让UI展示⾮常迟缓，⽽相⽐之下重排的性能影响更⼤，在两者⽆ 法避免的情况下，⼀般我们宁可选择代价更⼩的重绘。 

如果修改了元素的背景颜色，并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫`重绘`。 **相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。**

『重绘』不⼀定会出现『重排』，『重排』必然会出现『重绘』。

https://www.jianshu.com/p/639aa67bd7ca

## 如何触发重排和重绘？ 

任何改变⽤来构建渲染树的信息都会导致⼀次重排或重绘： 

通过display: none隐藏⼀个DOM节点-触发重排和重绘 

通过visibility: hidden隐藏⼀个DOM节点-只触发重绘，因为没有⼏何变化 

**引发重排的操作：**

- 页面首次渲染。
- 浏览器窗口大小发生改变——`resize`事件发生时。
- 元素尺寸或位置发生改变——定位、边距、填充、边框、宽度和高度。
- 元素内容变化（文字数量或图片大小等等）。
- 元素字体大小变化。
- 添加或者删除可见的DOM元素。
- 激活CSS伪类（例如：:hover）。
- 设置style属性
- 查询某些属性或调用某些方法。

**引起重排属性和方法：**

```undefined
width、 display、 clientWidth、 offsetWidth、 scrollWidth、 scrollIntoView()、 
getBoundingClientRect()、 height、 border、 clientHeight、 offsetHeight、 
scrollHeight、 scrollTo()、 scrollIntoViewIfNeeded()、 margin、 position、 
clientTop、 offsetTop、 scrollTop、 getComputedStyle()、 padding、 overflow、 
clientLeft、 offsetLeft、 scrollLeft
```

**引起重绘的属性：**

```rust
color、 text-decoration、 outline-color、 outline-width、 
border-style、 background-image、 outline、 box-shadow、 
visibility、 background-position、 outline-style、 
background-size、 background、 background-repeat、 border-radius
```

## 如何避免重绘或者重排？ 

**集中改变样式** 

我们往往通过改变class的⽅式来集中改变样式

**使⽤DocumentFragment** 

我们可以通过createDocumentFragment创建⼀个游离于DOM树之外的节点，然后在此节点上批量操作，最后插⼊ DOM树中，因此只触发⼀次重排

**提升为合成层**

将元素提升为合成层有以下优点： 

合成层的位图，会交由 GPU 合成，⽐ CPU 处理要快 

当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层 

对于 transform 和 opacity 效果，不会触发 layout 和 paint

```
提升合成层的最好⽅式是使⽤ CSS 的 will-change 属性
```

# VUE

https://juejin.cn/post/6850037277675454478

## 单页面应用 SPA

1、 优点 

1) 有良好的交互体验
   能提升页面切换体验，用户在访问应用页面是不会频繁的去切换浏览页面，从而避免了页面的重新加载；
2) 前后端分离开发
   单页Web应用可以和 RESTful 规约一起使用，通过 REST API 提供接口数据，并使用 Ajax 异步获取，这样有助于分离客户端和服务器端工作。更进一步，可以在客户端也可以分解为静态页面和页面交互两个部分；
3) 减轻服务器压力
   服务器只用出数据就可以，不用管展示逻辑和页面合成，吞吐能力会提高几倍；
4) 共用一套后端程序代码
   不用修改后端程序代码就可以同时用于 Web 界面、手机、平板等多种客户端；

2、缺点：

1) SEO难度较高
   由于所有的内容都在一个页面中动态替换显示，所以在SEO上其有着天然的弱势，所以如果你的站点对SEO很看重，且要用单页应用，那么就做些静态页面给搜索引擎用吧；
2) 前进、后退管理
   由于单页Web应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理，当然此问题也有解决方案，比如利用URI中的散列+iframe实现；
3) 初次加载耗时多
   为实现单页Web应用功能及显示效果，需要在加载页面的时候将JavaScript、CSS统一加载，部分页面可以在需要的时候加载。所以必须对JavaScript及CSS代码进行合并压缩处理；

## 你对MVVM的理解?

- View是视图层，也就是用户界面。前端主要由HTML和CSS来构成，为了更方便地展现ViewModel或者Model层的数据。
- Model是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，主要围绕数据库系统展开。这里的难点主要在于需要和前端约定统一的接口规则。
- ViewModel由前端开发人员组织生成和维护的视图数据层。在这一层，前端开发者从后端获取得到Model数据进行转换出来，做二次封装，以生成符合View层使用预期的视图数据模型。视图状态和行为都封装在ViewModel里。这样的封装使得ViewModel可以完整地去描述View层。
- ![img](https://pic3.zhimg.com/80/v2-13a6c3c1709ae8060f67ff776db0bdf6_720w.jpg)
- MVVM(Model-View-ViewModel)是一种软件架构设计模式，它是一种简化用户界面的事件驱动编程方式。
- 在MVVM架构中，是不允许数据和视图直接通信的，只能通过ViewModel来通信，而ViewModel就是定义了一个Observer观察者。ViewModel是连接View和Model的中间件。
  - ViewModel能够观察到数据的变化，并对视图对应的内容进行更新。
  - ViewModel能够监听到视图的变化，并能够通知数据发生变化。
  - 该层向上与视图层进行双向数据绑定。向下与Model层通过接口请求进行数据交互。

## 为什么要使用MVVM

- 低耦合：视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的View上，当View变化的时候Model可以不变，当Model变化的时候，View也可以不变。
- 可复用：可以把一些视图逻辑放到一个ViewModel里面，让很多View重用这段视图逻辑。
- 独立开发：开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。
- 可测试：界面素来是比较难于测试的，而现在测试可以针对ViewModel来写。
- Vue.js 是一个提供了 MVVM 风格的双向数据绑定的 Javascript 库，专注于View 层。它的核心是 MVVM 中的 VM，也就是 ViewModel。ViewModel负责连接 View 和 Model，保证视图和数据的一致性，这种轻量级的架构让前端开发更加高效、便捷。

## MVVM与MVC的区别

1、mvvm各部分的通信是双向的，而mvc各部分通信是单向的；

2、mvvm是真正将页面与数据逻辑分离放到js里去实现，而mvc里面未分离。

## 发布订阅模式和观察者模式

全局事件总线的设计就使用到了前端最重要的设计模式之一**发布订阅模式**，一般使用场景有以下特点：

1. 组件或者事物之间需要通讯，如进行变化通知，但是两者并没有或者无法直接进行通讯（彼此无感知），而是借助于第三方进行代理
2. 在发布方和订阅方上，存在有一对多的关系，一个发布者可以对应多个订阅者，当发布者发布信息时，订阅这条信息的订阅方都会进行响应

补充：如果你有了解过观察者模式，你会发现这个类似观察者模式，但是其实两者存在区别，关键点在于是否存在第三方桥梁，观察者模式是由观察者同被观察者直接通讯，两者能够相互感知，逻辑上存在一定的耦合（这种耦合并不是说不好，而是由于两者之间本就存在功能上的关系依赖），而发布订阅模式是订阅方和发布方无需直接通讯，两者无需感知对方，借由第三方进行协助通讯。

## 异步请求适合在哪个⽣命周期调⽤？

 官⽅实例的异步请求是在mounted⽣命周期中调⽤的，⽽实际上也可以在created⽣命周期中调⽤

## 分析Vue生命周期

​    常用的生命周期钩子：

​      1.mounted: 发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】。

​      2.beforeDestroy: 清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】。

​    关于销毁Vue实例

​      1.销毁后借助Vue开发者工具看不到任何信息。

​      2.销毁后自定义事件会失效，但原生DOM事件依然有效。

​      3.一般不会在beforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程了。

![image-20220708091925569](C:\Users\YangXuanhao\AppData\Roaming\Typora\typora-user-images\image-20220708091925569.png)

![1.png](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/19/16ca74f183827f46~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

3. **一旦进入到页面或者组件，会执行哪些生命周期，顺序。**

    beforeCreate
    created
    beforeMount
    mounted

4. **在哪个阶段有$el，在哪个阶段有$data**
   	beforeCreate 啥也没有
   	created  有data没有el
   	beforeMount 有data没有el
   	mounted 都有

4. **如果加入了keep-alive会多俩个生命周期**
    activated、deactivated
5. **如果加入了keep-alive，第一次进入组件会执行哪些生命？**
 beforeCreate
    created
    beforeMount
    mounted
    activated
6. **如果加入了keep-alive，第二次或者第N次进入组件会执行哪些生命周期？**
    只执行一个生命周期：activated

## v-if和v-show

* **v-show**严格意义来说其实是**条件隐藏**，直接在页面初始化的时候将DOM(对象模型)元素也初始化，因为它就是将**它所在的元素添加一个display属性为none**，如果条件符合就显示。
* **v-if**严格意义来说就是**条件判断**，符合就加载DOM(对象模型)元素，不符合就不显示。
* ① **v-if**有**更高的切换性能**，比如说**需要判断多个条件时，就使用if**。
  ② 如果需要频繁的切换，选择**v-show**，因为show是**动态的改变样式**，不需要增删DOM(对象模型)元素，**大项目推荐使用show**，能极大减少浏览器后期的操作性能。

v-if 与 v-show 都能控制dom元素在页面的显示

v-if 相比 v-show 开销更大的（直接操作dom节点增加与删除）

如果需要非常频繁地切换，则使用 v-show 较好

如果在运行时条件很少改变，则使用 v-if 较好

## keep-alive的生命周期

指定组件是否需要被缓存。

keep-alive 缓存特殊的两个阶段：

5、activated(组件激活时)

被 keep-alive 缓存的组件激活时调用。初始化操作放在actived里面

6、deactivated(组件停用时)

被 keep-alive 缓存的组件停用时调用。在deactived里面，在里面进行一些善后操作

## nextTick

在下次**DOM 更新循环结束之后执行延迟回调**。在修改数据之后立即使用这个方法，获取更新后的 DOM。

当项目中你想在**改变DOM元素的数据后**基于新的dom做点什么，**对新DOM一系列的js操作都需要放进Vue.nextTick()的回调函数中；**通俗的理解是：更改数据后当你想立即使用js操作新的视图的时候需要使用它

Vue.nextTick(callback) 使用原理：
原因是，Vue是异步执行dom更新的，一旦观察到数据变化，Vue就会开启一个队列，然后把在同一个事件循环 (event loop) 当中观察到数据变化的 watcher 推送进这个队列。如果这个watcher被触发多次，只会被推送到队列一次。这种缓冲行为可以有效的去掉重复数据造成的不必要的计算和DOm操作。而在下一个事件循环时，Vue会清空队列，并进行必要的DOM更新。
当你设置 vm.someData = 'new value'，DOM 并不会马上更新，而是在异步队列被清除，也就是下一个事件循环开始时执行更新时才会进行必要的DOM更新。如果此时你想要根据更新的 DOM 状态去做某些事情，就会出现问题。。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用。

## Vue组件如何通信?

* 父传子：` props 只可以从上一级组件传递到下一级组件（父子组件），是单向数据流。而且 prop 只读，不可被修改，所有修改都会失效并警告`。

  * 传递数据：```<Demo name="xxx"/>```

  * 接收数据：

    1. 第一种方式（只接收）：```props:['name'] ```
    2. 第二种方式（限制类型）：```props:{name:String}```
    3. 第三种方式（限制类型、限制必要性、指定默认值）：

    ```js
    props:{
    	name:{
    	type:String, //类型
    	required:true, //必要性
    	default:'老王' //默认值
    	}
    }
    ```

* 子传父：自定义事件

  * 绑定自定义事件：

    * 第一种方式，在父组件中：```<Demo @atguigu="test"/>```  或 ```<Demo v-on:atguigu="test"/>```

    * 第二种方式，在父组件中：


````
```js
<Demo ref="demo"/>
......
mounted(){
   this.$refs.xxx.$on('atguigu',this.test)
}
```
````

  * 子组件触发自定义事件：```this.$emit('atguigu',数据)```		

  * 解绑自定义事件```this.$off('atguigu')`

* 任意组件间通信:全局事件总线（GlobalEventBus）

  * 安装全局事件总线：

    ```js
    new Vue({
    	......
    	beforeCreate() {
    		Vue.prototype.$bus = this //安装全局事件总线，$bus就是当前应用的vm
    	},
        ......
    }) 
    ```

  * 接收数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的<span style="color:red">回调留在A组件自身。</span>

    ```js
    methods(){
      demo(data){......}
    }
    ......
    mounted() {
      this.$bus.$on('xxxx',this.demo)
    
    ```

  * 提供数据：```this.$bus.$emit('xxxx',数据)```

* 任意组件间通信:Vuex

* 任意组件间通信：消息订阅与发布（pubsub）

  * 安装pubsub：```npm i pubsub-js```

  * 引入: ```import pubsub from 'pubsub-js'```

  * 接收数据：A组件想接收数据，则在A组件中订阅消息，订阅的<span style="color:red">回调留在A组件自身。</span>

    ```js
    methods(){
      demo(data){......}
    }
    ......
    mounted() {
      this.pid = pubsub.subscribe('xxx',this.demo) //订阅消息
    }
    ```

  * 提供数据：```pubsub.publish('xxx',数据)```

## computed和watch有什么区别? 

* **computed**
  （**一个数据受多个数据影响**）
  在computed中定义的每一个计算属性，都会被缓存起来，只有当计算属性里面依赖的一个或多个属性变化了，才会重新计算当前计算属性的值。
  1、**支持数据的缓存**。
  2、**函数内部的数据改变也会触发**。
  3、**不支持异步**，当computed内部有异步操作时computed无效
  4、如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，一般用computed
  5、computed 属性值会**默认走缓存**，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值。（**return里面不用声明定义变量就可以进行监听观察数据变化的。**）
* **watch**
  watch是属性监听器，一般用来监听属性的变化（也可以用来监听计算属性函数），并做一些操作
  1、**不支持缓存**
  2、**支持异步**
  3、只可以设置一个函数，可以带有两个参数
  4、监听数据**必须是data中声明**过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作。（return里面必须声明定义变量才能进行监听。）

​		5、可选属性 immediate(组件加载立即触发监听一次)和deep(深度监听，监听对象内部属性)

## props和data优先级谁高？

```
props ===>  methods ===> data ===> computed ===>watch
```

## Vuex有哪些属性？

```
state、getters、mutations、actions、modules

state 类似于组件中data，存放数据
getters 类型于组件中computed 有缓存
mutations 类似于组件中methods 都是同步事物
actions 提交mutations的，不直接改变状态 可以包含任意异步操作
modules 把以上4个属性再细分，让仓库更好管理
```

<img src="C:\Users\YangXuanhao\AppData\Roaming\Typora\typora-user-images\image-20220830105334971.png" alt="image-20220830105334971" style="zoom:67%;" />

## vue、vuex都是单向数据流

vue是单项数据流。虽然vue有双向绑定“v-model”，但是vue父子组件之间数据传递，仍然还是遵循单向数据流的，父组件可以向子组件传递props，但是子组件不能修改父组件传递来的props，子组件只能通过事件通知父组件进行数据更改。

这实际上是为了更好的解耦，在开发中如果有多个子组件依赖与父组件的某个数据，万一子组件真的可以直接修改父组件的数据，那么一个子组件的变化将会引发所有依赖于这个数据的子组件的变化，所以vue不推荐子组件直接修改父组件的数据，直接修改prop会抛出警告。

## Vue路由模式

```
路由模式有俩种：history、hash
区别：
	1. 表现形态不同
			history:http://localhost:8080/about
			hash:http://localhost:8080/#/about
	2. 跳转请求
			history : http://localhost:8080/id   ===>发送请求
			hash 	  : 不会发送请求
	3. 打包后前端自测要使用hash，如果使用history会出现空白页
```

## Vue路径传值

```
1. 显式
	http://localhost:8080/about?a=1
	1.1 传：this.$router.push({
  			path:'/about',
  			query:{
  				a:1
  			}
  		})
  1.2 接：this.$route.query.a
  
2. 隐式
	http://localhost:8080/about
	2.1 传：this.$router.push({
  			name:'About',
  			params:{
  				a:1
  			}
  		})
  2.2 接：this.$route.params.a
```

## 路由导航守卫有哪些	

```
全局、路由独享、组件内

1. 全局
	beforeEach、beforeResolve、afterEach
2. 路由独享
	beforeEnter
3. 组件内
	beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave
	
使用场景：判断是否登录，如果登录就next否则就跳转到登录页面
```

## Vue是如何实现双向绑定的

1. vue 双向数据绑定是通过 数据劫持 结合 发布订阅模式 的方式来实现的， 也就是说数据和视图同步，数据发生变化，视图跟着变化，视图变化，数据也随之发生改变；
2. 核心：关于VUE双向数据绑定，其核心是 Object.defineProperty()方法；
3. 首先要对数据进行劫持监听，所以我们需要设置一个监听器Observer，用来监听所有属性。如果属性发上变化了，就需要告诉订阅者Watcher看是否需要更新。因为订阅者是有很多个，所以我们需要有一个消息订阅器Dep来专门收集这些订阅者，然后在监听器Observer和订阅者Watcher之间进行统一管理的。接着，我们还需要有一个指令解析器Compile，对每个节点元素进行扫描和解析，将相关指令（如v-model，v-on）对应初始化成一个订阅者Watcher，并替换模板数据或者绑定相应的函数，此时当订阅者Watcher接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。

因此接下去我们执行以下3个步骤，实现数据的双向绑定：

实现一个监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。

实现一个订阅者Watcher，每一个Watcher都绑定一个更新函数，watcher可以收到属性的变化通知并执行相应的函数，从而更新视图。

实现一个解析器Compile，可以扫描和解析每个节点的相关指令（v-model，v-on等指令），如果节点存在v-model，v-on等指令，则解析器Compile初始化这类节点的模板数据，使之可以显示在视图上，然后初始化相应的订阅者（Watcher）

## Proxy与Object.defineProperty的优劣对⽐?

Proxy的优势如下:

- Proxy可以直接监听对象而非属性
- Proxy可以直接监听数组的变化
- Proxy有多达13种拦截方法,不限于apply、ownKeys、deleteProperty、has等等是`Object.defineProperty`不具备的
- Proxy返回的是一个新对象,我们可以只操作新的对象达到目的,而`Object.defineProperty`只能遍历对象属性直接修改
- Proxy作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利

Object.defineProperty的优势如下:

- 兼容性好,支持IE9

## 你是如何理解Vue的响应式系统的?

1. Vue的data上的属性会被添加 getter 和 setter 属性。

2. 当 Vue Component render 函数被执行的时候，data上会被读，getter 方法会被调用，此时Vue会去记录此Vue Component 所依赖的所有data（这一过程被称为依赖收集）。

3. data 被改动时（主要是用户操作），即被写，setter 方法会调用，此时Vue会通知所有依赖于此 data 的组件调用它们的 render 函数进行更新。

4. 每个组件实例都对应一个 **watcher** 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201206170152643.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ltYWdpbmVfdGlvbg==,size_16,color_FFFFFF,t_70#pic_center)

## 既然Vue通过数据劫持可以精准探测数据变化,为什么还需要虚拟 DOM进行diff检测差异?

Vue 初始化的时候就会对 data 的数据进行依赖收集，因此Vue能实时知道那里发生了变化，但只针对组件级别的进行响应式监听也就是push，这样可以知道那个组件发生了变化，再对组件进行diff算法找到具体变化的位置，这是pull操作，vue是pull + push 结合进行变化侦测的。

## Vue中key的作用

* 虚拟DOM的key的作用：

　　key是虚拟DOM对象的标识，当状态中的数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】，
　　随后Vue进【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：

* 对比规则：

　　（1）旧虚拟DOM中找到了与新虚拟DOM相同的key：
　　　　　　若虚拟DOM中内容没变，直接使用之前的真实DOM
　　　　　　若虚拟DOM中内容变了，则生成新的真实DOM，随后替换掉页面中之前的真实DOM
　　（2）旧虚拟DOM中未找到与新虚拟DOM相同的key
　　　　　　创建新的真实DOM，随后渲染到页面

* 用index作为key可能会引发的问题

　　（1）若对数据进行：逆序添加、逆序删除等破坏顺序操作：
　　　　　　会产生没有必要的真实DOM更新 ==> 界面效果没问题，但效率低。
　　（2）如果结构中还包含输入类的DOM
　　　　　　会产生错误DOM更新 ==> 界面有问题。

* 开发中如何选择key？

　　（1）最好使用每条数据唯一表示作为key，比如id、手机号、身份证号、学号等唯一值。
　　（2）如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用index作为key是没有问题的

## Vue中diff算法的原理

diff的原理就是当前的真实的dom生成一颗virtual DOM也就是虚拟DOM，当虚拟DOM的某个节点的数据发生改变会生成一个新的Vnode, 然后这个Vnode和旧的oldVnode对比，发现有不同，直接修改在真实DOM上。

对于同一层次的一组子节点，它们可以通过唯一的id进行区分。

只比较同级的节点，若找不到与新节点类型相同的节点，则插入一个新节点，若有相同类型的节点则进行节点属性的更新，最后删除新节点列表中不包含的旧节点。



​	1、如果新老节点不是同一个节点名称，那么就暴力删除旧的节点，创建插入新的节点。

​	2、只能同级比较，不能跨层比较。如果跨层那么就暴力删除旧的节点，创建插入新的节点。

​	3、如果是相同节点，又分为很多情况

```
3.1 新节点有没有children
		如果新的节点没有children，那就证明新节点是文本，那直接把旧的替换成新的文本
3.2 新节点有children
		新的有children，旧的也有children ===》就是diff算法的核心了【3.3】
		新的有children，旧的没有 ===》创建元素添加（把旧的内容删除清空掉，增加新的）
```

```
3.3 diff算法的核心（最复杂的情况）

1、 旧前 和 新前
		匹配：旧前的指针++ 、 新前的指针++
2、 旧后 和 新后
		匹配：旧后的指针-- 、 新后的指针--
3、 旧前 和 新后
		匹配：旧前的指针++ 、 新后的指针--
4、 旧后 和 新前
		匹配：旧后的指针-- 、 新前的指针++
5、 以上都不满足条件 ===》查找
		新的指针++，新的添加到页面上并且新在旧的种有，要给旧的复制成undefined
6、 创建或者删除

```

***注意：如果要提升性能，一定要加入key，key是唯一标示，在更改前后，确认是不是同一个节点。

## 路由懒加载

整个网页默认是刚打开就去加载所有页面，路由懒加载就是只加载你当前点击的那个模块。

按需去加载路由对应的资源，提高首屏加载速度（tip:首页不用设置懒加载，而且一个页面加载过后再次访问不会重复加载）。

实现原理：将路由相关的组件，不再直接导入了，而是改写成异步组件的写法，只有当函数被调用的时候，才去加载对应的组件内容。

(1)   当打包构建应用时，JS包会变得非常大，影响页面加载。如果我们能**把不同路由对应的组件分割成不同的代码块**，然后当路由被访问的时候才加载对应组件，这样就更加高效了

(2)   本质就是**Vue** **的异步组件**在路由组件上的应用

(3)   需要使用动态import语法, 也就是import()函数

# 前端安全

https://blog.csdn.net/weixin_43675915/article/details/117719889

## 有哪些可能引起前端安全的的问题?

1、跨站脚本攻击（Cross-Site Scripting ，XSS）
一种代码注入方式，为了与css区分所以称之为XSS。早期常见于网络论坛，起因是网站没有对用户的输入进行严格的限制，使得攻击者可以将脚本上传到帖子让其他人在浏览器到有恶意的脚本页面。

2、iframe滥用
iframe中的内容是由第三方来提供的，默认情况下它们不受我们的限制，它们可以在iframe中运行Javascript脚本、Flash插件、弹出对话框等。

3、跨站请求伪造（Cross-Site Request Forgeries ， CSRF）
指攻击者通过设计好的陷进，强制对于完成认证的用户进行非预期的个人信息或设定信息等某些状态更新，属于被动攻击。

4、恶意第三方库
无论开发服务端还是客户端，绝大多数的时候我们都在借助开发框架和第三方工具进行快速开发，一旦第三方库被植入恶意代码就容易引起安全问题。

## CSRF

CSRF（Cross-site request forgery）跨站请求伪造。

**攻击原理**

1. 用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；
2. 在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；
3. 用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；
4. 网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；
5. 浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。

**防御措施**

1. Token验证
2. Referer 验证（简单易行，但 referer 可能被改变）
3. 隐藏令牌（跟 Token验证差不多，把令牌存到 header 中）

## XSS

XSS（cross-site scripting）跨域脚本攻击

**攻击原理**

往 Web 页面里插入恶意Script代码

**防御措施**

1. HTML：对以下这些字符进行转义：

```ini
&：&amp;
<：&alt;
>：&gt;
'：&#x27;
"：&quot;
/：&#x2F;
复制代码
```

1. Javascript：把所有非字母、数字的字符都转义成小于256的ASCII字符；

2. URL：使用Javascript的encodeURIComponent()方法对用户的输入进行编码，该方法会编码如下字符：

   ```bash
   ,      /      ?     :     @     &     =     +     $     #
   ```

# 前端工程化

## babel的作用是什么？

Babel是将[ES6](https://so.csdn.net/so/search?q=ES6&spm=1001.2101.3001.7020)及以上版本的代码转换为ES5的工具。

它用 babel.config.js 或 .babelrc 文件作为配置文件，其中最为重要的配置参数是presets和plugins。

## 什么是git

Git是一个分布式的版本管理工具，它分为远程仓库（云端仓库，存在后端服务器中）（仓库：repository简写repo：）和本地仓库。本地和云端的仓库的维护机制是类似的，它们都是使用一个类似一个树形结构的数据结构来维护的。每次的文件内容的改变都是一个节点(blob节点)，每个commit都是一个tree节点，节点中附带代码的操作信息和节点类型。详见：传送门。

## git的优点

git 是分布式的，有本地分支管理功能，所以，就算没有网络也可以进行本地的维护。
git的每个变动都是一个节点因此，每次的文件内容的变动都可以单独保存并且可以逐个的进行应用管理。在所有代码合并后也可以看到所有变更内容，而其他的版本管理工具则不可以。
由于git每次的变更都会生成一个完整的文件快照，所以它非常快。用空间来换取时间。
由于git会面临内存问题，它有自己的内存维护机制比如：删掉无用的节点，压缩打包历史记录等…
git有非常多的命令，可以灵活的使用。详见：传送门

## webpack

https://juejin.cn/post/7137987107020079111

Webpack是基于模块化打包的⼯具: ⾃动化处理模块,webpack把⼀切当成模块，当 webpack 处理应⽤程序时，它会递归地构建⼀个依赖关系图 (dependency

 graph)，其中包含应⽤程序需要的每个模块，然后将所有这些模块打包成⼀个或多个 bundle

mode: 指定打包的模式，development 或 production。

devtool：指定生成 sourceMap 的方式。

entry：配置入口文件，多文件打包的话要打包几个文件，就在 entry 中写几个入口，output 的 filename 用占位符 `[name]` 表示。

output: 出口。

loader：辅助打包的各种工具。

plugins：插件，loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。如 HtmlWebpackPlugin，CleanWebpackPlugin。

devServer：使用 WebpackDevServer 开启热更新，提升开发效率。

## webpack中有哪些常见的loader

1、file-loader：把⽂件输出到⼀个⽂件夹中，在代码中通过相对 URL 去引⽤输出的⽂件。
2、url-loader：和 file-loader 类似，但是能在⽂件很⼩的情况下以 base64 的⽅式把⽂件内容注⼊到代码中去。
3、source-map-loader：加载额外的 Source Map ⽂件，以⽅便断点调试。
4、image-loader：载并且压缩图⽚⽂件。
5、babel-loader：将ES6转化为ES5。
6、css-loader：加载 CSS，⽀持模块化、压缩、⽂件导⼊等特性。
7、style-loader：把 CSS 代码注⼊到 JavaScript 中，通过 DOM 操作去加载 CSS。
8、eslint-loader:通过 ESLint 检查 JavaScript 代码。

## 有哪些常⻅的Plugin？

define-plugin：定义环境变量 

**html-webpack-plugin：简化html⽂件创建** 

**uglifyjs-webpack-plugin：通过 UglifyES 压缩 ES6 代码**

webpack- parallel-uglify-plugin: 多核压缩,提⾼压缩速度

webpack-bundle- analyzer: 可视化webpack输出⽂件的体积

mini-css-extract-plugin: CSS提取到单独的⽂件中,⽀持按需加载

## 如何用webpack来优化前端性能？ 

首先，用webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运行快速高效。

* 压缩代码：
  * 删除多余的代码、注释、简化代码的写法等等方式。可以利用webpack的UglifyJsPlugin和ParallelUhlifyPlugin来压缩JS文件，利用cssnano（css-loader？minimize）来压缩css

* 利用CDN加速：
  * 在构建过程中，将引用的静态资源路径修改为CDN上对应的路径。可以利用
    webpack对于output参数和各种loader的publicPath参数来修改资源路径

* Tree Shaking
  * 消除最终文件中未使用的代码。可以通过在启动webpack时追加参数–optimize-minimize来实现

* Code Splitting
  * 将代码按路由维度或者组件分块（chunk），这样做到按需加载，同时可以充分利用浏览器缓存

* 提供公共第三方库
  * SplitChunksPlugin插件来进行公共模块抽取，利用浏览器缓存可以长期缓存这些无需频繁变动的公共代码

## loader和plugin的区别

两者都是为了扩展webpack的功能。

**Loader**直译为"加载器"。Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到loader。 所以Loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力。

**loader的作用**：
1、实现对不同格式的文件的处理，比如说将scss转换为css，或者typescript转化为js
2、转换这些文件，从而使其能够被添加到依赖图中
loader是webpack最重要的部分之一，通过使用不同的Loader，我们能够调用外部的脚本或者工具，实现对不同格式文件的处理，loader需要在webpack.config.js里边单独用module进行配置，

```
test: 匹配所处理文件的扩展名的正则表达式（必须）
    loader: loader的名称（必须）
    include/exclude: 手动添加处理的文件，屏蔽不需要处理的文件（可选）
    query: 为loaders提供额外的设置选项
    ex: 
        var baseConfig = {
            // ...
            module: {
                rules: [
                    {
                        test: /*匹配文件后缀名的正则*/,
                        use: [
                            loader: /*loader名字*/,
                            query: /*额外配置*/
                        ]
                    }
                ]
            }
        }

```

要是loader工作，我们需要一个正则表达式来标识我们要修改的文件，然后有一个数组表示
我们表示我们即将使用的Loader,当然我们需要的loader需要通过npm 进行安装。例如我们需要解析less的文件，那么webpack.config.js的配置如下：

```
var baseConfig = {
                entry: {
                    main: './src/index.js'
                },
                output: {
                    filename: '[name].js',
                    path: path.resolve('./build')
                },
                devServer: {
                    contentBase: './src',
                    historyApiFallBack: true,
                    inline: true
                },
                module: {
                    rules: [
                        {
                            test: /\.less$/,
                            use: [
                                {loader: 'style-loader'},
                                {loader: 'css-loader'},
                                {loader: 'less-loader'}
                            ],
                            exclude: /node_modules/
                        }
                    ]
                }
            }
```

这里介绍几个常用的loader：
babel-loader： 让下一代的js文件转换成现代浏览器能够支持的JS文件。
babel有些复杂，所以大多数都会新建一个.babelrc进行配置
css-loader,style-loader:两个建议配合使用，用来解析css文件，能够解释@import,url()如果需要解析less就在后面加一个less-loader
file-loader: 生成的文件名就是文件内容的MD5哈希值并会保留所引用资源的原始扩展名
url-loader: 功能类似 file-loader,但是文件大小低于指定的限制时，可以返回一个DataURL事实上，在使用less,scss,stylus这些的时候，npm会提示你差什么插件，差什么，你就安上就行了



**Plugin**直译为"插件"。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。plugin也是为了扩展webpack的功能，但是 plugin 是作用于webpack本身上的。而且plugin不仅只局限在打包，资源的加载上，它的功能要更加丰富。从打包优化和压缩，到重新定义环境变量，功能强大到可以用来处理各种各样的任务。

plugins和loader很容易搞混，说都是外部引用有什么区别呢？ 事实上他们是两个完全不同的东西。这么说**loaders负责的是处理源文件的如css、jsx，一次处理一个文件。而plugins并不是直接操作单个文件，**它直接对整个构建过程起作用下面列举了一些我们常用的plugins和他的用法
ExtractTextWebpackPlugin: 它会将入口中引用css文件，都打包都独立的css文件中，而不是内嵌在js打包文件中。下面是他的应用

## webpack 构建流程分析

![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71b263000fa94db792cf1e98d67a578a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

`webpack` 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：首先会从配置文件和 `Shell` 语句中读取与合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数；初始化完成后会调用`Compiler`的`run`来真正启动`webpack`编译构建过程，`webpack`的构建流程包括`compile`、`make`、`build`、`seal`、`emit`阶段，执行完这些阶段就完成了构建过程。











# 操作系统

## 进程和线程的区别

功能：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位

开销：每个进程都有独立的内存空间，存放代码和数据段等，程序之间的切换会有较大的开销；线程可以看做轻量级的进程，共享内存空间，每个线程都有自己独立的运行栈和程序计数器，线程之间切换的开销小。

运行环境：在操作系统中能同时运行多个进程；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）

创建过程：在创建新进程的时候，会将父进程的所有五大数据结构复制新的，形成自己新的内存空间数据，而在创建新线程的时候，则是引用进程的五大数据结构数据，但是线程会有自己的私有数据、栈空间。

进程和线程其实在cpu看来都是task_struct结构的一个封装，执行不同task即可，而且在cpu看来就是在执行这些task时候遵循对应的调度策略以及上下文资源切换定义，包括寄存器地址切换，内核栈切换。所以对于cpu而言，进程和线程是没有区别的。

# 计网

##**HTTP请求报文与响应报文格式**

**请求报文包含三部分：**
a、请求行：包含请求方法、URI、HTTP版本信息
b、请求首部字段
c、请求内容实体
**响应报文包含三部分：**
a、状态行：包含HTTP版本、状态码、状态码的原因短语
b、响应首部字段
c、响应内容实体

https://blog.csdn.net/qq_37269404/article/details/102292588?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-102292588-blog-98642450.pc_relevant_aa_2&spm=1001.2101.3001.4242.1&utm_relevant_index=3









## 简述OSI七层协议

OSI七层协议包括：物理层，数据链路层，网络层，运输层，会话层，表示层， 应用层

## **简述TCP/IP五层协议**

TCP/IP五层协议包括：物理层，数据链路层，网络层，运输层，应用层

## **物理层有什么作用**

主要解决两台物理机之间的通信，通过二进制比特流的传输来实现，二进制数据表现为电流电压上的强弱，到达目的地再转化为二进制机器码。网卡、集线器工作在这一层。

## **数据链路层有什么作用**

在不可靠的物理介质上提供可靠的传输，接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层。这一层在物理层提供的比特流的基础上，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路。提供物理地址寻址功能。**交换机**工作在这一层。

## **网络层有什么作用**

将网络地址翻译成对应的物理地址，并决定如何将数据从发送方路由到接收方，通过路由选择算法为分组通过通信子网选择最佳路径。**路由器**工作在这一层。

## **传输层有什么作用**

传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。

## **会话层有什么作用**

建立会话：身份验证，权限鉴定等； 保持会话：对该会话进行维护，在会话维持期间两者可以随时使用这条会话传输局； 断开会话：当应用程序或应用层规定的超时时间到期后，OSI会话层才会释放这条会话。

## **表示层有什么作用**

对数据格式进行编译，对收到或发出的数据根据应用层的特征进行处理，如处理为文字、图片、音频、视频、文档等，还可以对压缩文件进行解压缩、对加密文件进行解密等。

## **应用层有什么作用**

提供应用层协议，如HTTP协议，FTP协议等等，方便应用程序之间进行通信。

## **TCP与UDP区别**

TCP作为面向字节流的协议，提供可靠的、面向连接的运输服务，并且提供点对点通信 

UDP作为面向报文的协议，不提供可靠交付，并且不需要连接，不仅仅对点对点，也支持多播和广播

## **为何TCP可靠**

TCP有**三次握手**建立连接，**四次挥手**关闭连接的机制。 除此之外还有**滑动窗口**和**拥塞控制**算法。最最关键的是还保留**超时重传的机制**。 对于每份**报文也存在校验**，保证每份报文可靠性。

## **为何UDP不可靠**

UDP面向数据报无连接的，数据报发出去，就不保留数据备份了。 仅仅在IP数据报头部加入校验和复用。 UDP没有服务器和客户端的概念。 UDP报文过长的话是交给IP切成小段，如果某段报废报文就废了。

## **简述TCP粘包现象**

TCP是面向流协议，发送的单位是字节流，因此会将多个小尺寸数据被封装在一个tcp报文中发出去的可能性。 可以简单的理解成客户端调用了两次send，服务器端一个recv就把信息都读出来了。

## **TCP粘包现象处理方法**

固定发送信息长度，或在两个信息之间加入分隔符。

## **简述TCP协议的滑动窗口**

滑动窗口是传输层进行流量控制的一种措施，接收方通过通告发 送方自己的窗口大小，从而控制发送方的发送速度，防止发送方发送速度过快而导致自己被淹没。

## **简述TCP协议的拥塞控制**

拥塞是指一个或者多个交换点的数据报超载，TCP又会有重传机制，导致过载。 为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量.

当cwnd < ssthresh 时，使用慢开始算法。 当cwnd > ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。 当cwnd = ssthresh 时，即可使用慢开始算法，也可使用拥塞避免算法。

慢开始：由小到大逐渐增加拥塞窗口的大小，每接一次报文，cwnd指数增加。

拥塞避免：cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1。

快恢复之前的策略：发送方判断网络出现拥塞，就把ssthresh设置为出现拥塞时发送方窗口值的一半，继续执行慢开始，之后进行拥塞避免。

快恢复：发送方判断网络出现拥塞，就把ssthresh设置为出现拥塞时发送方窗口值的一半，并把cwnd设置为ssthresh的一半，之后进行拥塞避免。

## **简述快重传**

如果在超时重传定时器溢出之前，接收到连续的三个重复冗余ACK，发送端便知晓哪个报文段在传输过程中丢失了，于是重发该报文段，不需要等待超时重传定时器溢出再发送该报文。

## **TCP三次握手过程**

1. 第一次握手:客户端将标志位SYN置为1，随机产生一个值序列号seq=x，并将该数据包发送给服务端，客户端 进入syn_sent状态，等待服务端确认。
2. 第二次握手:服务端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务端将标志位SYN和 ACK都置为1，ack=x+1,随机产生一个值seq=y，并将该数据包发送给客户端以确认连接请求，服务端进入syn_rcvd状态。
3. 第三次握手:客户端收到确认后检查,如果正确则将标志位ACK为1，ack=y+1，并将该数据包发送给服务端，服务端进行检查如果正确则连接建立成功，客户端和服务端进入established状态，完成三次握手，随后客户端和服务端之间可以开始传输 数据了

## **为什么TCP握手需要三次，两次行不行？**

不行。TCP进行可靠传输的关键就在于维护一个序列号，三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值。

如果只是两次握手， 至多只有客户端的起始序列号能被确认， 服务器端的序列号则得不到确认。

假定不采用第三次握手，那么只要B发出确认，新的连接就建立了，一直等待A发送数据过来，使得B的许多资源就浪费了，所以采用三次握手的方法可以防止上述现象的发生。

## **简述半连接队列**

TCP握手中，当服务器处于SYN_RCVD 状态，服务器会把此种状态下请求连接放在一个队列里，该队列称为半连接队列。

## **简述SYN攻击**

SYN攻击即利用TCP协议缺陷，通过发送大量的半连接请求，占用半连接队列，耗费CPU和内存资源。

优化方式：

1. 缩短SYN Timeout时间
2. 记录IP，若连续受到某个IP的重复SYN报文，从这个IP地址来的包会被一概丢弃。

## **TCP四次挥手过程**

1. 第一次挥手：客户端发送一个FIN，用来关闭客户端到服务端的数据传送，客户端进入fin_wait_1状态。
2. 第二次挥手：服务端收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1，服务端进入Close_wait状态。此时TCP连接处于半关闭状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。
3. 第三次挥手：服务端发送一个FIN，用来关闭服务端到客户端的数据传送，服务端进入Last_ack状态。
4. 第四次挥手：客户端收到FIN后，客户端进入Time_wait状态，接着发送一个ACK给服务端，确认后，服务端进入Closed状态，完成四次挥手。

## **为什么TCP挥手需要4次**

主要原因是当服务端收到客户端的 FIN 数据包后，服务端可能还有数据没发完，不会立即close。

所以服务端会先将 ACK 发过去告诉客户端我收到你的断开请求了，但请再给我一点时间，这段时间用来发送剩下的数据报文，发完之后再将 FIN 包发给客户端表示现在可以断了。之后客户端需要收到 FIN 包后发送 ACK 确认断开信息给服务端。

## **为什么四次挥手释放连接时需要等待2MSL**

MSL即报文最大生存时间。设置2MSL可以保证**上一次连接的报文已经在网络中消失，不会出现与新TCP连接报文冲突**的情况。

## **简述DNS协议**

DNS协议是基于UDP的应用层协议，它的功能是根据用户输入的域名，解析出该域名对应的IP地址，从而给客户端进行访问。

## **简述DNS解析过程**

1、客户机发出查询请求，在本地计算机缓存查找，若没有找到，就会将请求发送给dns服务器

2、本地dns服务器会在自己的区域里面查找，找到即根据此记录进行解析，若没有找到，就会在本地的缓存里面查找

3、本地服务器没有找到客户机查询的信息，就会将此请求发送到根域名dns服务器

4、根域名服务器解析客户机请求的根域部分，它把包含的下一级的dns服务器的地址返回到客户机的dns服务器地址

5、客户机的dns服务器根据返回的信息接着访问下一级的dns服务器

6、这样递归的方法一级一级接近查询的目标，最后在有目标域名的服务器上面得到相应的IP信息

7、客户机的本地的dns服务器会将查询结果返回给我们的客户机

8、客户机根据得到的ip信息访问目标主机，完成解析过程



像问路一样 本地==》 根==》顶级==》权威

1. 客户端⾸先会发出⼀个 DNS 请求，问 www.server.com 的 IP 是啥，并发给本地 DNS 服务器（也就是客户端
的 TCP/IP 设置中填写的 DNS 服务器地址）。
2. 本地域名服务器收到客户端的请求后，如果缓存⾥的表格能找到 www.server.com，则它直接返回 IP 地址。
如果没有，本地 DNS 会去问它的根域名服务器：“⽼⼤， 能告诉我 www.server.com 的 IP 地址吗？” 根域名
服务器是最⾼层次的，它不直接⽤于域名解析，但能指明⼀条道路。
3. 根 DNS 收到来⾃本地 DNS 的请求后，发现后置是 .com，说：“www.server.com 这个域名归 .com 区域管
理”，我给你 .com 顶级域名服务器地址给你，你去问问它吧。”
4. 本地 DNS 收到顶级域名服务器的地址后，发起请求问“⽼⼆， 你能告诉我 www.server.com 的 IP 地址吗？”
5. 顶级域名服务器说：“我给你负责 www.server.com 区域的权威 DNS 服务器的地址，你去问它应该能问到”。
6. 本地 DNS 于是转向问权威 DNS 服务器：“⽼三，www.server.com对应的IP是啥呀？” server.com 的权威
DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。
7. 权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。
8. 本地 DNS 再将 IP 地址返回客户端，客户端和⽬标建⽴连接。



## **简述HTTP协议**

http协议是超文本传输协议。它是基于TCP协议的应用层传输协议，即客户端和服务端进行数据传输的一种规则。该协议本身HTTP 是一种无状态的协议。

## **简述cookie**

HTTP 协议本身是无状态的，为了使其能处理更加复杂的逻辑，HTTP/1.1 引入 Cookie 来保存状态信息。

Cookie是由服务端产生的，再发送给客户端保存，当客户端再次访问的时候，服务器可根据cookie辨识客户端是哪个，以此可以做个性化推送，免账号密码登录等等。

## **简述session**

session用于标记特定客户端信息，存在在服务器的一个文件里。 一般客户端带Cookie对服务器进行访问，可通过cookie中的session id从整个session中查询到服务器记录的关于客户端的信息。

## **简述http状态码和对应的信息**

- **1XX 信息**

\1. 100 Continue ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。

- **2XX 成功**

\1. 200 OK

\2. 204 No Content ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。

\3. 206 Partial Content ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。

- **3XX 重定向**

\1. 301 Moved Permanently ：永久性重定向；

\2. 302 Found ：临时性重定向；

\3. 303 See Other ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。

\4. 304 Not Modified ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。

\5. 307 Temporary Redirect ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。

- **4XX 客户端错误**

\1. 400 Bad Request ：请求报文中存在语法错误。

\2. 401 Unauthorized ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。

\3. 403 Forbidden ：请求被拒绝。

\4. 404 Not Found

- **5XX 服务器错误**

\1. 500 Internal Server Error ：服务器正在执行请求时发生错误；

\2. 503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。

## **转发和重定向的区别**

转发是服务器行为。服务器直接向目标地址访问URL,将相应内容读取之后发给浏览器，用户浏览器地址栏URL不变，转发页面和转发到的页面可以共享request里面的数据。

重定向是利用服务器返回的状态码来实现的，如果服务器返回301或者302，浏览器收到新的消息后自动跳转到新的网址重新请求资源。用户的地址栏url会发生改变，而且不能共享数据。

## **简述http1.0**

规定了请求头和请求尾，响应头和响应尾（get post）

每一个请求都是一个单独的连接，做不到连接的复用

## **简述http1.1的改进**

HTTP1.1默认开启**长连接**，在一个TCP连接上可以传送多个HTTP请求和响应。使用 TCP 长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。

支持**管道（pipeline）网络传输**，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。



存在 **队头阻塞**问题

发送冗⻓的⾸部

没有请求优先级控制

服务端无法主动push

## **简述HTTP短连接与长连接区别**

HTTP中的长连接短连接指HTTP底层TCP的连接。

短连接： 客户端与服务器进行一次HTTP连接操作，就进行一次TCP连接，连接结束TCP关闭连接。

长连接：如果HTTP头部带有参数**keep-alive**，即开启长连接网页完成打开后，底层用于传输数据的TCP连接不会直接关闭，会根据服务器设置的保持时间保持连接，保持时间过后连接关闭。

## **简述http2.0的改进**

1. HTTP/2 会**压缩头（Header）**如果你同时发出多个请求，他们的头是⼀样的或是相似的，那么，协议会帮你消除重 复的部分。 这就是所谓的 HPACK 算法：在客户端和服务器同时维护⼀张头信息表，所有字段都会存⼊这个表，⽣成⼀个索 引号，以后就不发送同样字段了，只发送索引号，这样就提⾼速度了

2. 提出**多路复用**。多路复用前，文件时串行传输的，请求a文件，b文件只能等待，并且连接数过多。引入多路复用，a文件b文件可以同时传输。

3. 引入了**二进制数据帧**。其中帧对数据进行顺序标识，有了序列id，服务器就可以进行并行传输数据。
   HTTP/2 的数据包不是按顺序发送的，同⼀个连接⾥⾯连续的数据包，可能属于不同的回应。因此，必须要对数据
   包做标记，指出它属于哪个回应。
   每个请求或回应的所有数据包，称为⼀个数据流（ Stream ）。每个数据流都标记着⼀个独⼀⽆⼆的编号，其中规
   定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数
   客户端还可以指定数据流的优先级。优先级⾼的请求，服务器就先响应该请求

5. **服务器推送** 

   HTTP/2 还在⼀定程度上改善了传统的「请求 - 应答」⼯作模式，服务不再是被动地响应，也可以主动向客户端发 送消息。 举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会⽤到的 JS、CSS ⽂件等静态资源主动发给客户端，减 少延时的等待，也就是服务器推送（Server Push，也叫 Cache Push）。

## **http与https的区别**

http所有传输的内容都是明文，并且客户端和服务器端都无法验证对方的身份。 https具有安全性的ssl加密传输协议，加密采用对称加密， https协议需要到ca申请证书，一般免费证书很少，需要交费。

## **简述TLS/SSL, HTTP, HTTPS的关系**

SSL全称为Secure Sockets Layer即安全套接层，其继任为TLSTransport Layer Security传输层安全协议，均用于在传输层为数据通讯提供安全支持。

可以将HTTPS协议简单理解为HTTP协议＋TLS/SSL

## **https的连接过程**

1. 浏览器将支持的加密算法信息发给服务器 + 随机数C
2. 服务器选择一套浏览器支持的加密算法，以证书的形式回发给浏览器 +随机数S
3. 客户端(SSL/TLS)解析证书验证证书合法性，生成对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，用服务器的公钥对preMaster进行非对称加密。  C+S+preMaster
4. 客户端会发起HTTPS中的第二个HTTP请求，将加密之后的会话密钥发送给服务器
5. 服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是会话密钥，然后用会话密钥对数据进行对称加密，这样数据就变成了密文。
6. 服务器将加密后的密文发送给客户端
7. 客户端收到服务器发送来的密文，用会话密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成

## **Get与Post区别**

数据传输⽅式不同：GET请求通过URL传输数据，⽽POST的数据通过请求体传输。 

安全性不同：POST的数据因为在请求主体内，所以有⼀定的安全性保证，⽽GET的数据在URL中，通过历史记 录，缓存很容易查到数据信息。 

数据类型不同：GET只允许 ASCII 字符，⽽POST⽆限制 

GET⽆害： 刷新、后退等浏览器操作GET请求是⽆害的，POST可能重复提交表单 



GET ⽅法就是安全且幂等的、POST 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多 个资源，所以不是幂等的

## **Get方法参数有大小限制吗**

一般HTTP协议里并不限制参数大小限制。但一般由于get请求是直接附加到地址栏里面的，由于浏览器地址栏有长度限制，因此使GET请求在浏览器实现层面上看会有长度限制。

## **了解REST API吗**

REST API全称为表述性状态转移（Representational State Transfer，REST）即利用HTTP中get、post、put、delete以及其他的HTTP方法构成REST中数据资源的增删改查操作：

- Create ： POST
- Read ： GET
- Update ： PUT/PATCH
- Delete： DELETE

## **浏览器中输入一个网址URL后，具体发生了什么**

1. 进行DNS解析操作，根据DNS解析的结果查到服务器IP地址
2. 通过ip寻址和arp，找到服务器，并利用三次握手建立TCP连接
3. 浏览器生成HTTP报文，发送HTTP请求，等待服务器响应
4. 服务器处理请求，并返回给浏览器
5. 根据HTTP是否开启长连接，进行TCP的挥手过程
6. 浏览器根据收到的静态资源进行页面渲染

### 1. 计网基础

#### 1. 说说计算机网络有哪两种通信方式？⭐⭐⭐

1. 第一种方式：**客户-服务器方式。**这种传统的方式是互联网上最常见的方式。**客户是服务请求方，服务器是服务提供方。**

   C/S模型有一个特例，那就是**B/S**（Browse/Server）模型，即浏览器／服务器模式，也叫B/S结构。它只安装维护一个服务器（Server），而客户端采用浏览器（Browse）运行软件。B/S结构是随着Internet技术的兴起，对C/S结构的变化和改进。它和C/S并没有本质区别。

2. 第二种通信方式：**对等连接（P2P）方式。**是指两台主机在通信时并不区分哪一个是服务请求方哪一个是服务提供方。只要两台主机都运行了对等连接软件（P2P软件），他们就可以进行对等连接通信。

#### 2. 什么是分组交换？优缺点？⭐⭐⭐

分组交换采用存储转发技术，把一个**报文**划分为几个**分组**后再进行传送。分组的首部非常重要，包含了**目的地址和源地址**等重要控制信息，这样每一个分组才能在互联网中独立地选择传输路径，并被正确地交付到分组传输的终点，最后再组合起来。

**优点：**

（1）高效，在分组传输时动态分配带宽，对通信链路逐段占用。

（2）灵活，为每一个分组独立地选择最合适的转发路由。

（3）迅速，以分组为单位，可以不先建立连接就能向主机发送数据。

（4）可靠，分布式多路由的分组交换网，使传输鲁棒性强。

**缺点：**

（1）分组在路由器存储转发时需要排队，有时延。

（2）分组必须携带控制信息（头部）也造成了开销。

#### 3. 请说说OSI七层协议模型？⭐⭐⭐⭐

![图片说明](https://uploadfiles.nowcoder.com/images/20210310/675098158_1615350055223/9EB60BC8BF2B004E4DB7D1CC0D5F1D8C)



![image-20210627130137568](C:\Users\PrinceBo\AppData\Roaming\Typora\typora-user-images\image-20210627130137568.png)

![image-20210420161119153](C:\Users\PrinceBo\AppData\Roaming\Typora\typora-user-images\image-20210420161119153.png)

#### 4. 子网掩码的作用⭐⭐⭐

（1）一是用于屏蔽IP地址的一部分以区别网络标识和主机标识，并说明该IP地址是在局域网上，还是在远程网上。
（2）二是用于将一个大的IP网络划分为若干小的子网络。

#### 5. 请说说TCP/IP四层分层模型？⭐⭐⭐⭐

![图片说明](https://uploadfiles.nowcoder.com/images/20210310/675098158_1615350167408/9EB60BC8BF2B004E4DB7D1CC0D5F1D8C)

![image-20210420160243063](C:\Users\PrinceBo\AppData\Roaming\Typora\typora-user-images\image-20210420160243063.png)

#### 6. 请说说TCP/IP四层分层模型，每个分层说两个协议。⭐⭐⭐⭐⭐

1. **应用层**：应用层是体系结构中的最高层。其任务是**通过应用进程间的交互来完成特定网络应用**。应用层协议定义了**应用进程间通信和交互的规则**。

   常用应用层协议如：

   域名系统**DNS**：DNS协议是用来将域名转换为IP地址（也可以将IP地址转换为相应的域名地址）。使用UDP传输，因为UDP快啊！UDP的DNS协议只要一个请求、一个应答就好了

   支持互联网应用的协议**HTTP**：超文本传输协议，在浏览器与服务器间传送文档。

   **SMTP**协议：简单邮件传送协议

   **FTP**协议：文件传输协议

   **RIP** 协议：距离矢量路由选择协议。

2. **传输层**：也称运输层。其任务是为**两台主机中进程之间的通信**提供**通用的数据传输服务**。

   主要有两种协议：

   **TCP：**提供面向连接的、可靠的数据传输服务。

   **UDP：**提供无连接的、尽最大努力可靠交付的传输服务。

   **SCTP** (Stream Control Transmission Protocol)是一种传输协议，在TCP/IP协议栈中所处的位置和TCP、UDP类似，兼有TCP/UDP两者特征。

3. **网络层**：其**任务是负责为分组交换网上的不同主机提供通信服务**。

   常用协议如：

   **IP** 协议：（1） 寻址。（2） 路由选择。（3） 分段与组装。

   **ICMP**协议：用于在IP主机、路由器之间传递控制消息，用来提供网络诊断信息 。

4. **网络接口层（链路层）**：两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要专门的链路层协议。

   **ARP**协议：ARP地址解析协议用于将计算机的网络地址（IP地址32位）转化为物理地址（MAC地址48位）

   **RARP**协议：RARP协议（Reverse ARP，反向ARP协议），其功能是将MAC地址解析为对应的IP地址。

#### 7. TCP与UDP的区别？⭐⭐⭐⭐⭐

（1）TCP需要建立一对一稳定连接；UDP无连接

（2）TCP一对一；UDP可以一对一、一对多、多对多

（3）TCP可靠传输，序列号、确认应答、超时重传；UDP不保证可靠传输，尽最大努力交付

（4）TCP头部字节20字节；UDP8个字节

（5）TCP开销大；UDP灵活开销小

（6）TCP提供可靠的服务，适用于通讯质量要求高的场景；UDP传输效率高，适用于高速传输和实时性要求的场景。

#### 8. TCP头部包含哪些内容？⭐⭐⭐⭐

TCP头部如图：

![图片说明](https://uploadfiles.nowcoder.com/images/20210310/675098158_1615350590236/F19C9085129709EE14D013BE869DF69B)

```c++
//TCP头定义，共20个字节
typedef struct _TCP_HEADER{
    short m_sSourPort;          //源端口号16位
    short m_sDestPort;          //目的端口号16位
    unsigned int m_uiSequNum;   //序列号32位
    unsigned int m_uiAcknowlNum;//确认号32位
    short m_sHeaderLenAndFlag;  //前4位：TCP头长度；中6位：保留；后6位：标志位。共16位
    short m_sWindowSize;        //窗口大小16位
    short m_sCheckSum;          //校验和16位
    short m_surgentPointer;     //紧急数据偏移量16位
}__attribute__((packed))TCP_HEADER, *PTCP_HEADER;
```



**豆芽点评**

无

![img](https://uploadfiles.nowcoder.com/images/20210401/675098158_1617275570568/C9B128652F7516422E61C6650420328C)

### 2. 计算机网络之TCP挥手与握手

![img](https://uploadfiles.nowcoder.com/images/20210401/675098158_1617275570568/C9B128652F7516422E61C6650420328C)

#### 1. TCP为什么要三次握手，能两次吗？⭐⭐⭐⭐⭐

不能两次

假如只进行两次握手，客户端发送连接请求后，会等待服务器端的应答。但是会出现的问题是，假如客户端的SYN迟迟没有到达服务器端，此时客户端超时后，会重新发送一次连接，假如重发的这次服务器端收到了，且应答客户端了，连接建立了。

但是建立后，第一个SYN也到达服务端了，这时服务端会认为这是一个新连接，会再给客户端发送一个ACK，这个ACK当然会被客户端丢弃。但是此时服务器端已经为这个连接分配资源了，而且服务器端会一直维持着这个资源，会造成资源浪费。

**两次握手的问题在于服务器端不知道SYN的有效性**，所以如果是三次握手，服务器端会等待客户端的第三次握手，如果第三次握手迟迟不来，服务器端就会**释放相关资源**。

#### 2. TCP为什么要四次挥手，能三次吗？⭐⭐⭐⭐⭐

不能三次。

第二次挥手和第三次挥手不能合并在一起，这是因为第二次挥手后，服务器端可能还在传输数据，需要等待数据传输完毕后再进行第三次挥手。

#### 3. 说说TCP三次握手的过程。⭐⭐⭐⭐⭐

**三次握手**：

1. Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，等待Server确认。
2. Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置1，ack=J+1，随机产生一个值seq=K，并将该数据包发给Client以确认连接请求。
3. Client收到确认后，检测ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server。完成三次握手，随后Client与Server之间可以开始传输数据了。
   ![图片说明](https://uploadfiles.nowcoder.com/images/20210328/675098158_1616935582182/602E8F042F463DC47EBFDF6A94ED5A6D)

#### 4. 说说TCP四次挥手的过程。⭐⭐⭐⭐⭐

**四次挥手**：

1. 数据传输结束后，Client的应用进程发出连接释放报文段FIN，并停止发送数据，此时Client依然可以接收Server发送来的数据。
2. Server接收到FIN后，发送一个ACK给Client，确认序号为收到的序号+1。
3. 当Server没有数据要发送时，Server发送一个FIN报文，等待Client的确认。
4. Client收到Server的FIN报文后，给Server发送一个ACK报文，确认序列号为收到的序号+1。此时Client进入TIME_WAIT状态，等待2MSL（MSL：报文段最大生存时间），然后关闭连接。

#### 5. 为什么第四次挥手后，客户端需要等待2MSL？ ⭐⭐⭐⭐⭐

这是**为了保证客户端发送的最后一个ACK报文段能够到达服务器**。如果客户端不等待2MSL，这个ACK报文段可能丢失，因而使得处在LAST-ACK状态的服务器收不到ACK报文段的确认，导致服务器无法正常关闭。而如果客户端等待2MSL，服务器就会超时重传FIN报文段，而客户端就能在2MSL时间内收到这个重传的FIN-ACK报文段。接着客户端重传一个确认，重新启动2MSL计时器。当服务器收到最后一个ACK后就可以正常关闭了。

**2MSL的意义是，经过2MSL后，所有的报文都会消失，不会影响下一次连接。最后客户端和服务器端都能正常进入到CLOSED状态。**

#### 6. 什么是洪泛攻击？怎么避免？⭐⭐⭐⭐⭐

A（攻击者）发送TCP SYN，SYN是TCP三次握手中的第一个数据包，而当这个服务器返回ACK以后，A不再进行确认，那这个连接就处在了一个挂起的状态，也就是半连接的意思，那么服务器收不到再确认的一个消息，还会重复发送ACK给A。

这样一来就会更加浪费服务器的资源。A就对服务器发送非法大量的这种TCP连接，由于每一个都没法完成握手的机制，所以它就会消耗服务器的内存最后可能导致服务器死机，就无法正常工作了。更进一步说，如果这些半连接的握手请求是恶意程序发出，并且持续不断，那么就会导致服务端较长时间内丧失服务功能——这样就形成了DoS攻击。这种攻击方式就称为SYN泛洪攻击。

**避免方法：**

最常用的一个手段就是优化主机系统设置。

（1）比如**降低SYN timeout时间**，使得主机尽快释放半连接的占用。

（2）或者采用**SYN cookie设置**，如果短时间内收到了某个IP的重复SYN请求，我们就认为受到了攻击。我们合理的采用防huo墙（汉字竟然会被屏蔽，有点意思，只能打拼音了）设置等外部网络进行拦截。

（3）**使用长连接**。在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的 TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。

#### 7. 如何应对短连接、高并发的场景？⭐⭐⭐⭐⭐

1. 针对于大量短连接同时高并发的情况：
   最常用的一个手段就是优化主机系统设置。

   （1）比如**降低SYN timeout时间**，使得主机尽快释放半连接的占用。

   （2）或者采用**SYN cookie设置**，如果短时间内收到了某个IP的重复SYN请求，我们就认为受到了攻击。我们合理的采用防huo墙（汉字竟然会被屏蔽，有点意思，只能打拼音了）设置等外部网络进行拦截。

   （3）**使用长连接**。在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的 TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。

2. 而针对于服务器高并发的场景，有以下处理手段：
   （1）采用多IO复用模型，如select、epoll，甚至采用异步IO

   （2）采用队列进行削峰、缓存

   （3）采用多服务器负载均衡手段

   （4）数据库层面我们可以采用分库分表、读写分离等措施。

   （5）还可以采用缓存的方式

#### 8. 说说TCP的可靠机制。⭐⭐⭐⭐⭐

**TCP保证可靠性**：

1. **序列号、确认应答、超时重传**
   数据到达接收方，接收方需要发出一个确认应答，表示已经收到该数据段，并且确认序列号，序列号说明了它下一次需要接收的数据序列号，保证数据传输有序。如果发送方迟迟未收到确认应答，那么可能是发送的数据丢失，也可能是确认应答丢失，这时发送方在等待一段时间后进行重传。
2. **窗口控制**
   TCP会利用窗口控制来提高传输速度，意思是在一个窗口大小内，不用一定等到应答才能发送下一段数据，窗口大小就是无需等待确认而可以继续发送数据的最大值。如果不使用窗口控制，每一个没收到确认应答的数据都要重发。
   使用窗口控制，如果数据段1001-2000丢失，后面数据每次传输，确认应答都会不停发送序号为1001的应答，表示我要接收1001开始的数据，发送端如果收到3次相同应答，就会立刻进行重发；数据一旦丢失，接收端会一直提醒。
3. **拥塞控制**
   如果把窗口定的很大，发送端连续发送大量的数据，可能造成网络的拥堵。为了防止拥堵，进行拥塞控制。
   （1）**慢启动**：定义拥塞窗口，一开始将该窗口大小设为1，之后每次收到一次确认应答，将拥塞窗口大小 乘以2
   （2）**拥塞避免**：设置慢启动阈值，一般开始都设为65536。拥塞避免是只当拥塞窗口大小达到这个阈值，拥塞窗口的值不再指数上升，而是+1
   （3）**快恢复**：将报文段的超时重传看做拥塞，则一旦发生超时重传，我们就将阈值设为当前窗口大小的一半，并且窗口大小变为1，重新进入慢启动过程
   （4）**快速重传**：3次重复确认应答，立即重传。

**补充：**

所谓慢启动，也就是TCP连接刚建立，一点一点地提速，试探一下网络的承受能力，以免直接扰乱了网络通道的秩序。

**慢启动算法：**

1) 连接建好的开始先初始化拥塞窗口cwnd大小为1，表明可以传一个MSS大小的数据。

2) 每当收到一个ACK，cwnd大小加一，呈线性上升。

3) 每当过了一个往返延迟时间RTT(Round-Trip Time)，cwnd大小直接翻倍，乘以2，呈指数让升。

4) 还有一个ssthresh（slow start threshold），是一个上限，当cwnd >= ssthresh时，就会进入“拥塞

避免算法”（后面会说这个算法）

**拥塞避免算法** **– Congestion Avoidance**

如同前边说的，当拥塞窗口大小cwnd大于等于慢启动阈值ssthresh后，就进入拥塞避免算法。算法如下：

1) 收到一个ACK，则cwnd = cwnd + 1 / cwnd

2) 每当过了一个往返延迟时间RTT，cwnd大小加一。

过了慢启动阈值后，拥塞避免算法可以避免窗口增长过快导致窗口拥塞，而是缓慢的增加调整到网络的最佳值。

**拥塞发生状态时的算法**

一般来说，TCP拥塞控制默认认为网络丢包是由于网络拥塞导致的，所以一般的TCP拥塞控制算法以丢包为网络进入拥塞状态的信号。对于丢包有两种判定方式，一种是超时重传RTO[RetransmissionTimeout]超时，另一个是收到三个重复确认ACK。

超时重传是TCP协议保证数据可靠性的一个重要机制，其原理是在发送一个数据以后就开启一个计时器，在一定时间内如果没有得到发送数据报的ACK报文，那么就重新发送数据，直到发送成功为止。

但是如果发送端接收到3个以上的重复ACK，TCP就意识到数据发生丢失，需要重传。这个机制不需要等到重传定时器超时，所以叫做快速重传，而快速重传后没有使用慢启动算法，而是拥塞避免算法，所以这又叫做快速恢复算法。

重传RTO[Retransmission Timeout]超时，TCP会重传数据包。TCP认为这种情况比较糟糕，反应也比较强烈：

1. 由于发生丢包，将慢启动阈值ssthresh设置为当前cwnd的一半，即ssthresh = cwnd / 2.
2. cwnd重置为1
3. 进入慢启动过程

最为早期的TCP Tahoe算法就只使用上述处理办法，但是由于一丢包就一切重来，导致cwnd又重置为1，十分不利于网络数据的稳定传递。

所以，TCP Reno算法进行了优化。当收到三个重复确认ACK时，TCP开启快速重传Fast Retransmit算法，而不用等到RTO超时再进行重传：

1. cwnd大小缩小为当前的一半
2. ssthresh设置为缩小后的cwnd大小
3. 然后进入快速恢复算法Fast Recovery。

![image-20210420192419476](C:\Users\PrinceBo\AppData\Roaming\Typora\typora-user-images\image-20210420192419476.png)

**快速恢复算法** **– Fast Recovery**

 TCP Tahoe是早期的算法，所以没有快速恢复算法，而Reno算法有。在进入快速恢复之前，cwnd和ssthresh已经被更改为原有cwnd的一半。快速恢复算法的逻辑如下：

1. cwnd = cwnd + 3 *MSS*，加*3* MSS的原因是因为收到3个重复的ACK。
2. 重传DACKs指定的数据包。
3. 如果再收到DACKs，那么cwnd大小增加一。
4. 如果收到新的ACK，表明重传的包成功了，那么退出快速恢复算法。将cwnd设置为ssthresh，然后进入拥塞避免算法。

![image-20210420192631901](C:\Users\PrinceBo\AppData\Roaming\Typora\typora-user-images\image-20210420192631901.png)

如图所示，第五个包发生了丢失，所以导致接收方接收到三次重复ACK，也就是ACK5。所以将

ssthresh设置当当时cwnd的一半，也就是6/2 = 3，cwnd设置为3 + 3 = 6。然后重传第五个包。当收到新的ACK时，也就是ACK11，则退出快速恢复阶段，将cwnd重新设置为当前的ssthresh，也就是3，然后进入拥塞避免算法阶段。

#### 9. 请说说TCP的ACK机制，有什么好处？⭐⭐⭐⭐⭐

由于通信过程的不可靠性，传输的数据不可避免的会出现丢失、延迟、错误、重复等各种状况，TCP协议为解决这些问题设计了一系列机制。这个机制的核心，就是发送方向接收方发送数据后，接收方要向发送方发送ACK（回执）。如果发送方没接收到正确的ACK，就会重新发送数据直到接收到ACK为止。

比如：发送方发送的数据序号是seq，那么接收方会发送seq + 1作为ACK，这样发送方就知道接下来要发送序号为seq + 1的数据给接收方了。

#### 10. 如何让UDP也变得可靠？⭐⭐⭐⭐⭐

加入TCP可靠机制。

1. **序列号、确认应答、超时重传**
   数据到达接收方，接收方需要发出一个确认应答，表示已经收到该数据段，并且确认序列号，序列号说明了它下一次需要接收的数据序列号，保证数据传输有序。如果发送方迟迟未收到确认应答，那么可能是发送的数据丢失，也可能是确认应答丢失，这时发送方在等待一段时间后进行重传。
2. **窗口控制**
   TCP会利用窗口控制来提高传输速度，意思是在一个窗口大小内，不用一定等到应答才能发送下一段数据，窗口大小就是无需等待确认而可以继续发送数据的最大值。如果不使用窗口控制，每一个没收到确认应答的数据都要重发。
   使用窗口控制，如果数据段1001-2000丢失，后面数据每次传输，确认应答都会不停发送序号为1001的应答，表示我要接收1001开始的数据，发送端如果收到3次相同应答，就会立刻进行重发；数据一旦丢失，接收端会一直提醒。
3. **拥塞控制**
   如果把窗口定的很大，发送端连续发送大量的数据，可能造成网络的拥堵。为了防止拥堵，进行拥塞控制。
   （1）**慢启动**：定义拥塞窗口，一开始将该窗口大小设为1，之后每次收到一次确认应答，将拥塞窗口大小 乘以2
   （2）**拥塞避免**：设置慢启动阈值，一般开始都设为65536。拥塞避免是只当拥塞窗口大小达到这个阈值，拥塞窗口的值不再指数上升，而是+1
   （3）**快恢复**：将报文段的超时重传看做拥塞，则一旦发生超时重传，我们就将阈值设为当前窗口大小的一半，并且窗口大小变为1，重新进入慢启动过程
   （4）**快速重传**：3次重复确认应答，立即重传。

#### 11. 什么是负载均衡？⭐⭐⭐⭐⭐

当一台服务器的单位时间内的访问量越大时，服务器压力就越大，大到超过自身承受能力时，服务器就会崩溃。为了避免服务器崩溃，让用户有更好的体验，我们通过负载均衡的方式来分担服务器压力。
**什么是负载均衡**：我们可以建立很多很多服务器，组成一个服务器集群，当用户访问网站时，先访问一个中间服务器，再让这个中间服务器在服务器集群中选择一个压力较小的服务器，然后将该访问请求引入该服务器。如此以来，用户的每次访问，都会保证服务器集群中的每个服务器压力趋于平衡，分担了服务器压力，避免了服务器崩溃的情况。
**负载均衡有几种方式实现**
（1）轮询（默认）
请求依次轮流往每个应用服务器上进行分配，分配策略比较简单。
缺点：不均匀，可能会出现，某些服务器接受的请求较重，负载压力重，有些负荷小，不可控。另外服务器之间需要进行session同步。
（2）权重轮询（权重越高，进入的几率越大）
优点：可以根据情况进行调整。可控，仍然需要进行session同步。
（3）IP-Hash
优点：采用hash的方式来映射服务器。无需进行session同步，固定IP会固定访问一台服务器。
缺点：恶意攻击，会造成某台服务器压垮。提供的服务不同，面向的地区不同，IP可能会出现集中，造成不均匀，不可控。
（4）Fair
这种相当于自适应，会根据服务器处理请求的速度进行负载均衡分配。处理请求最早结束的，拿到下一个请求。看上去是不是很好。但是一般都不使用，说是考虑到网络不稳定因素。还有待研究。这种也需要进行session同步。
（5）URL-Hash
这种是根据URL进行hash，这样某些请求永远打某台服务器。利于利用服务器的缓存，但是可能由于URL的哈希值分布不均匀，以及业务侧重造成某些服务器压力大，某些负荷低。这种也需要进行session同步。

#### 12. Session和cookie的区别？⭐⭐⭐⭐⭐

由于HTTP是一种无状态协议,服务器没有办法单单从网络连接上面知道访问者的身份,为了解决这个问题,就诞生了Cookie

Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie

客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。

实际就是颁发一个通行证，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份了。这就是Cookie的工作原理

cookie 可以让服务端程序跟踪每个客户端的访问，但是每次客户端的访问都必须传回这些Cookie，如果 Cookie 很多，这无形地增加了客户端与服务端的数据传输量，

而 Session 的出现正是为了解决这个问题。同一个客户端每次和服务端交互时，不需要每次都传回所有的 Cookie 值，而是只要传回一个 ID，这个 ID 是客户端第一次访问服务器的时候生成的， 而且每个客户端是唯一的。这样每个客户端就有了一个唯一的 ID，客户端只要传回这个 ID 就行了，这个 ID 通常是 NANE 为JSESIONID 的一个 Cookie。
**区别**：

1、数据存放位置不同：cookie数据存放在客户的浏览器上，session数据放在服务器上。

2、安全程度不同：cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,考虑到安全应当使用session。

3、性能使用程度不同：session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能,考虑到减轻服务器性能方面，应当使用cookie。

4、数据存储大小不同：单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie，而session则存储与服务端，浏览器对其没有限制。
5、会话机制不同
session会话机制：session会话机制是一种服务器端机制，它使用类似于哈希表（可能还有哈希表）的结构来保存信息。

cookies会话机制：cookie是服务器存储在本地计算机上的小块文本，并随每个请求发送到同一服务器。 Web服务器使用HTTP标头将cookie发送到客户端。在客户端终端，浏览器解析cookie并将其保存为本地文件，该文件自动将来自同一服务器的任何请求绑定到这些cookie。

#### 13. 网络调试的工具？⭐⭐⭐⭐⭐

1. Ping命令：ping属于一个通信协议，是TCP/IP协议的一部分。利用“ping”命令可以检查网络是否通畅或者网络连接速度，很好地分析和判定网络故障。
   **它的原理是**：利用网络上机器IP地址的唯一性，给目标IP地址发送一个数据包，通过对方回复的数据包来确定两台网络机器是否连接相通，时延是多少。
2. Nslookup(name server lookup)是一个用于查询因特网域名信息或诊断DNS 服务器问题的工具.
3. Fiddler（中文名称：小提琴）是一个HTTP的调试代理，以代理服务器的方式，监听系统的Http网络数据流动，Fiddler可以也可以让你检查所有的HTTP通讯，设置断点，以及Fiddle所有的“进出”的数据
4. 网站压力测试工具——webbench

**豆芽点评**

TCP挥手和握手考点多，也很重要，全是五颗星，一定要掌握。

![img](https://uploadfiles.nowcoder.com/images/20210401/675098158_1617275570568/C9B128652F7516422E61C6650420328C)

### 3. 计算机网络之socket网络编程

![img](https://uploadfiles.nowcoder.com/images/20210401/675098158_1617275570568/C9B128652F7516422E61C6650420328C)

#### 1. 请说说socket网络编程的步骤。⭐⭐⭐⭐

![图片说明](https://uploadfiles.nowcoder.com/images/20210310/675098158_1615352649109/586E508F161F26CE94633729AC56C602)
（1）服务器根据地址类型（ ipv4, ipv6 ）、 socket 类型、协议创建 socket。

（2）服务器为 socket 绑定 IP 地址和端口号。

（3）服务器 socket 监听端口号请求，随时准备接收客户端发来的连接，这时候服务器的socket 并没有被打开 。

（4）客户端创建 socket。

（5）客户端打开 socket，根据服务器 IP 地址和端口号试图连接服务器 socket。

（6）服务器 socket 接收到客户端 socket 请求，被动打开，开始接收客户端请求，直到客户端返回连接信息 。这时候 socket 进入阻塞状态，所谓阻塞即accept（）方法一直到客户端返回连接信息后才返回，开始接收下一个客户端连接请求 。

（7）客户端连接成功，向服务器发送连接状态信息 。

（8）服务器 accept 方法返回，连接成功 。

（9）客户端向 socket 写入信息 。

（10）服务器读取信息 。

（11）客户端关闭 。

（12）服务器端关闭 。

#### 2. 请说说socket网络编程的接口。⭐⭐⭐⭐

1. socket函数创建接口
2. bind函数绑定IP地址和端口号
3. listen函数监听
4. accept接受客户端请求
5. close函数关闭socket
6. connect函数是客户端请求
7. read和write函数用来读取和发送数据

![image-20210420194150545](C:\Users\PrinceBo\AppData\Roaming\Typora\typora-user-images\image-20210420194150545.png)

服务器：





创建socket -> int socket(int domain, int type, int protocol);

domain：协议域，决定了socket的地址类型，IPv4为AF_INET。

type：指定socket类型，SOCK_STREAM为TCP连接。

protocol：指定协议。IPPROTO_TCP表示TCP协议，为0时自动选择type默认协议。

绑定socket和端口号 -> int bind(int sockfd, const struct sockaddr *addr, socklen_t 

addrlen);

sockfd：socket返回的套接字描述符，类似于文件描述符fd。

addr：有个sockaddr类型数据的指针，指向的是被绑定结构变量。

```c++
    // IPv4的sockaddr地址结构
    struct sockaddr_in {
        sa_family_t sin_family;    // 协议类型，AF_INET
        in_port_t sin_port;    // 端口号
        struct in_addr sin_addr;    // IP地址
   };
    struct in_addr {
        uint32_t s_addr;
   }
```

addrlen：地址长度。

监听端口号 -> int listen(int sockfd, int backlog);

sockfd：要监听的sock描述字。

backlog：socket可以排队的最大连接数。

接收用户请求 -> int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);

sockfd：服务器socket描述字。

addr：指向地址结构指针。

addrlen：协议地址长度。

注：一旦accept某个客户机请求成功将返回一个全新的描述符用于标识具体客户的TCP连接。

从socket中读取字符 -> ssize_t read(int fd, void *buf, size_t count);

fd：连接描述字。

buf：缓冲区buf。

count：缓冲区长度。

注：大于0表示读取的字节数，返回0表示文件读取结束，小于0表示发生错误。

关闭socket -> int close(int fd);

fd：accept返回的连接描述字，每个连接有一个，生命周期为连接周期。

注：sockfd是监听描述字，一个服务器只有一个，用于监听是否有连接；fd是连接描述

字，用于每个连接的操作。

客户机：

创建socket -> int socket(int domain, int type, int protocol);

连接指定计算机 -> int connect(int sockfd, struct sockaddr* addr, socklen_t addrlen);

sockfd客户端的sock描述字。

addr：服务器的地址。

addrlen：socket地址长度。

向socket写入信息 -> ssize_t write(int fd, const void *buf, size_t count);

fd、buf、count：同read中意义。

大于0表示写了部分或全部数据，小于0表示出错。

关闭socket -> int close(int fd);

fd：同服务器端fd。

#### 3. 什么是TCP粘包现象？⭐⭐⭐⭐⭐

在socket网络程序中，发送端为了将多个发往接收端的包，更有效的发到对方，使用了优化方法（**Nagle算法**），将多次间隔较小、数据量小的数据，合并成一个大的数据块，然后进行**封包**。这样，接收端就难于分辨出来了

#### 4. 为什么会出现粘包现象？如何解决？⭐⭐⭐⭐⭐

1. 由Nagle算法造成的**发送端粘包**。Nagle算法是一种改善网络传输效率的算法，但也可能造成困扰。这就造成了粘包。
2. 接收端接收不及时造成的**接收端粘包**。TCP会把接收到的数据存在自己的缓冲区中，然后通知应用层取数据。当应用层由于某些原因不能及时取出TCP的数据，就会造成TCP缓冲区中存放多段数据。

解决办法是：科学**封包和解包**。

#### 5. 简述一下Nagle算法⭐⭐⭐

Nagle算法简单的说，当提交一端数据给TCP时，TCP并不立刻发送此段数据，而是等待一段时间，看看在等待期间是否还有要发送的数据，若有则会一次吧多段数据发送出去。

#### 6. 为什么UDP不粘包⭐⭐⭐⭐⭐

对于UDP，不会使用块的合并优化算法，不存在封包，再加上**UDP本身是一个“数据包“协议**，也就是两段数据是有界限的。从TCP和UDP的**头部结构体**就可以很明显的看到，**UDP头部是记录了数据的长度的**，而**TCP头部里面并没有记录数据长度的变量**。
TCP头部
![图片说明](https://uploadfiles.nowcoder.com/images/20210310/675098158_1615352560346/9EB60BC8BF2B004E4DB7D1CC0D5F1D8C)
UDP头部
![图片说明](https://uploadfiles.nowcoder.com/images/20210310/675098158_1615352574403/C00B57557743E709B8B96933432E0DFA)

#### 7. 什么是封包和解包？⭐⭐⭐⭐⭐

**封包**就是给一段数据加上包头，这样一来数据包就分为包头和包体两部分内容了（可加上包尾）。包头其实是一个大小固定的结构体，其中有个**结构体成员变量**表示包体的长度，这是个很重要的变量，其他的结构体成员可根据需要自己定义。根据固定的包头长度以及包头中含有的包体长度变量值就能正确的拆分出一个完整的数据包。

利用底层的缓冲区来进行**解包**时，由于TCP也维护了一个缓冲区，所以可以利用TCP的缓冲区来**解包**，也就是循环不停地接收包头给出的数据，直到收够为止，这就是一个完整的TCP包。

**豆芽点评**

无

![img](https://uploadfiles.nowcoder.com/images/20210401/675098158_1617275570568/C9B128652F7516422E61C6650420328C)

### 4. 计算机网络之HTTP和HTTPS

![img](https://uploadfiles.nowcoder.com/images/20210401/675098158_1617275570568/C9B128652F7516422E61C6650420328C)

#### 1. 请说说HTTP的工作原理。⭐⭐⭐⭐⭐

HTTP协议采用了**请求/响应模型**。客户端向服务器发送一个**请求报文**，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，**响应**的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。

#### 2. 在浏览器地址栏键入URL，按下回车之后会经历哪些流程？⭐⭐⭐⭐⭐

1. 浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;

   总结： 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。

   一、主机向本地域名服务器的查询一般都是采用递归查询。

   二、本地域名服务器向根域名服务器的查询的迭代查询。

2. 解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;

3. 浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;

4. 服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;

5. 释放 TCP连接;

6. 浏览器解析html代码，并请求html代码中的资源，最后对页面进行渲染呈现给用户。

#### 3. 请你说说HTTP请求包含哪些内容？⭐⭐⭐⭐⭐

请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。

#### 4. 请说说有哪些请求方法？⭐⭐⭐⭐⭐

请求方法，**GET和POST**是最常见的HTTP方法，除此以外还包括DELETE、HEAD、OPTIONS、PUT、TRACE。

#### 5. get和post的区别是什么？⭐⭐⭐⭐⭐

1. get将数据放在url后面，post将数据放在报文体

2. url长度会受到特定的浏览器及服务器的限制，如IE对URL长度的限制是2083字节(2K+35)。而报文体长度没有限制

3. get将数据放在url后面，信息并不安全；post方法将数据放在报文体中，更安全。

4. GET产生一个TCP数据包，浏览器会把http header和data一并发送出去，服务器响应200(返回数据); POST产生两个TCP数据包，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。

   **有些文章中提到**，POST 会将 header 和 body 分开发送，先发送 header，服务端返回 100 状态码再发送 body。

   HTTP 协议中没有明确说明 POST 会产生两个 TCP 数据包，而且实际测试(Chrome)发现，header 和body 不会分开发送。

   所以，header 和 body 分开发送是部分浏览器或框架的请求方法，**不属于 post 必然行为。**

5. GET请求会被浏览器主动缓存，而POST不会，除非手动设置。

#### 6. 请你说说HTTP状态码⭐⭐⭐⭐⭐

| 状态码 | 意义                 | 解释                                                         |
| ------ | -------------------- | ------------------------------------------------------------ |
| 301    | Permanently Moved    | 被请求的资源已永久移动到新位置，新的URL在Location头中给出，浏览器应该自动地访问新的URL。301为永久重定向。 |
| 302    | Found                | 请求的资源现在临时从不同的URL响应请求。302为临时重定向。     |
| 200    | OK                   | 表示从客户端发来的请求在服务器端被正确处理                   |
| 304    | Not Modified         | 告诉浏览器可以从缓存中获取所请求的资源。                     |
| 400    | bad request          | 请求报文存在语法错误                                         |
| 403    | forbidden            | 表示对请求资源的访问被服务器拒绝                             |
| 404    | not found            | 表示在服务器上没有找到请求的资源                             |
| 500    | internal sever error | 表示服务器端在执行请求时发生了错误                           |
| 503    | service unavailable  | 表明服务器暂时处于超负载或正在停机维护，无法处理请求         |

![image-20210420194709216](C:\Users\PrinceBo\AppData\Roaming\Typora\typora-user-images\image-20210420194709216.png)

**1xx** **信息**

**100 Continue** ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。

**2xx** **成功**

**200 OK**

**204 No Content** ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。

**206 Partial Content** ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。

**3xx** **重定向**

**301 Moved Permanently** ：永久性重定向

**302 Found** ：临时性重定向

**303 See Other** ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。

**304 Not Modifified** ：如果请求报文首部包含一些条件，例如：If-Match，If-Modifified-Since，If-None-Match，If-Range，If-Unmodifified-Since，如果不满足条件，则服务器会返回 304 状态码。

**307 Temporary Redirect** ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。

**4xx** **客户端错误**

**400 Bad Request** ：请求报文中存在语法错误。

**401 Unauthorized** ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。

如果之前已进行过一次请求，则表示用户认证失败。

**403 Forbidden** ：请求被拒绝。

**404 Not Found**

**5xx** **服务器错误**

**500 Internal Server Error** ：服务器正在执行请求时发生错误。

**503 Service Unavailable** ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。

#### 7. 请说说HTTP响应头有哪些内容？⭐⭐⭐⭐⭐

HTTP响应也是由三个部分组成，分别是：状态行、消息报头、响应正文。

补充：

**请求报文**

简单来说：

请求行：Request Line

请求头：Request Headers

请求体：Request Body

**响应报文**

简单来说：

状态行：Status Line

响应头：Response Headers

响应体：Response Body

#### 8. 请说说HTTP协议的特点⭐⭐⭐⭐⭐

1. **支持客户/服务器模式**

   HTTP协议规定，请求从客户端发出，最后服务器端响应该请求并返回。换句话说，肯定是先从客户端开始建立通信的，服务器端在没有接收到请求之前不会发送响应。

2. **简单快速**

   客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。

3. **灵活**

   HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type（Content-Type是HTTP包中用来表示内容类型的标识）加以标记。

4. **无连接**

   无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。

5. **无状态**

   无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。即我们给服务器发送 HTTP 请求之后，服务器根据请求，会给我们发送数据过来，但是，发送完，不会记录任何信息。

#### 9. HTTP的无连接是什么意思？⭐⭐⭐⭐

无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。

#### 10. HTTP的无状态是什么意思？⭐⭐⭐⭐

无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。即我们给服务器发送 HTTP 请求之后，服务器根据请求，会给我们发送数据过来，但是，发送完，不会记录任何信息。

**豆芽点评**

HTTP和HTTPS内容十分重要，也是高频考点，必须掌握。

![img](https://uploadfiles.nowcoder.com/images/20210401/675098158_1617275570568/C9B128652F7516422E61C6650420328C)

#### 11. HTTP1.0、HTTP1.1的区别⭐⭐⭐⭐

1. **长连接(Persistent Connection)**：HTTP1.1支持长连接和请求的流水线处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。

2. **节约带宽**：HTTP1.0中存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能。HTTP1.1支持只发送header信息（不带任何body信息），如果服务器认为客户端有权限请求服务器，则返回100，客户端接收到100才开始把请求body发送到服务器；如果返回401，客户端就可以不用发送请求body了，节约了带宽。

3. **HOST域**：在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname），HTTP1.0没有host域。HTTP1.1的请求消息和响应消息都支持host域，且请求消息中如果没有host域会报告一个错误（400 Bad Request）。

4. **缓存处理**：在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。

5. HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法。

   HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。

#### 12. 什么是长连接？⭐⭐⭐⭐⭐

HTTP1.1规定了默认保持长连接（HTTP persistent connection ，也有翻译为持久连接），数据传输完成了**保持TCP连接不断开**（不发RST包、不四次握手），等待在同域名下继续用这个通道传输数据；相反的就是短连接。长连接的**好处**是效率高，**缺点**是占用资源。

#### 13. HTTP2.0有哪些改动？⭐⭐⭐

1. **多路复用**允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。
2. **二进制分帧**：在应用层(HTTP/2)和传输层(TCP or UDP)之间增加一个二进制分帧层。将所有传输的信息分割为更小的消息和帧（frame）,并对它们采用二进制格式的编码 ，其中 HTTP1.x 的首部信息会被封装到 HEADER frame，而相应的 Request Body 则封装到 DATA frame 里面。二进制分帧主要作用是二进制码鲁棒性高，增强了通信的稳定性。
3. **首部压缩**：http1.x的header由于cookie和user agent很容易膨胀，而且每次都要重复发送。http2.0使用encoder来减少需要传输的header大小
4. **服务端推送**：http2.0能通过push的方式将客户端需要的内容预先推送过去

#### 14. HTTPS的加密原理⭐⭐⭐⭐⭐

HTTPS采用**对称密钥**加密和**非对称密钥**加密加密两者混合加密，两者都有各自的优点。**对称密钥加密处理速度快，但密钥无法安全发送给对方**；**非对称密钥加密处理速度慢，但密钥能够安全交换**。但如果我们将两种加密方式一起使用，则两种加密方式就能互补。

也就是说，利用**非对称密钥**加密方式安全地交换在稍后的**对称密钥**加密中要使用的密钥，在确保密钥安全前提下，使用**对称密钥**加密方式进行通信。
![图片说明](https://uploadfiles.nowcoder.com/images/20210318/675098158_1616044528087/079F4FB55B755F6F198BEE97D7C95390)

#### 15. 什么是对称加密？什么是非对称加密？两者区别？⭐⭐⭐⭐

1. **对称密钥加密：加密与解密使用同一个密钥**

   也就是说在加密的同时，也会把密钥发送给对方。

2. **非对称密钥**

   **非对称密钥加密**有两把密钥。一把叫私有密钥，另一把叫公有密钥。私有密钥不让任何人知道，公有密钥随意发送。

#### 16. 对称加密有哪些？非对称加密有哪些？⭐⭐⭐⭐

一种是**对称密钥加密**例如：DES、AES-GCM、ChaCha20-Poly1305等，一种是**非对称密钥加密**，例如：RSA、DSA、ECDSA、 DH、ECDHE

#### 17. SSL中数字证书用来干嘛的？⭐⭐⭐⭐⭐

服务器会给客户端发出数字证书来证明自己的身份。**客户端在接受到服务端发来的SSL证书时，会对证书的真伪进行校验**。证书中包含的具体内容有：

1. 证书的发布机构CA
2. 证书的有效期
3. 公钥
4. 证书所有者
5. 签名

这样我们通过数字证书，就可以安全交换对称秘钥了，**既解决了公钥获取问题，又解决了黑客冒充问题**，一箭双雕。

**补充：**

数字证书认证机构（CA，Certifificate Authority）是客户端与服务器双方都可信赖的第三方机构。

服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。

进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。

#### 18. HTTPS为什么比HTTP更安全⭐⭐⭐⭐⭐

![图片说明](https://uploadfiles.nowcoder.com/images/20210310/675098158_1615353402463/9EB60BC8BF2B004E4DB7D1CC0D5F1D8C)
在HTTP基础上我们通过加密后，又衍生出了新的通信协议——**HTTPS**。HTTPS 协议（HyperText Transfer Protocol over Secure Socket Layer）：可以理解为**HTTP+SSL/TLS**， 即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL，用于安全的 HTTP 数据传输。

#### 19. HTTPS和HTTP的区别⭐⭐⭐⭐⭐

1. http是是明文传输，https则是具有安全性的tsl加密传输协议。
2. https除了三次握手以外，**还要进行ssl握手**，协商加密使用对称密钥
3. https需要服务端申请证书，浏览器端安装根证书
4. 端口也不一样，**前者是80，后者是443**

#### 20. HTTPS的通信建立过程⭐⭐⭐⭐⭐

![图片说明](https://uploadfiles.nowcoder.com/images/20210310/675098158_1615353376983/C00B57557743E709B8B96933432E0DFA)

1. 在使用HTTPS是需要保证服务端配置正确了对应的安全证书
2. 客户端发送请求到服务端
3. 服务端返回公钥和数字证书到客户端
4. 客户端接收后会验证证书的安全性，如果通过，则会随机生成一个随机对称秘钥，用公钥对其加密，发送到服务端
5. 服务端接受到这个加密后的随机对称秘钥后，会用私钥对其解密得到真正的随机对称秘钥，随后用这个随机对称秘钥当做**对称加密密钥**对需要发送的数据进行对称加密
6. 客户端在接收到加密后的数据**对称加密密钥**与服务器通信。
7. SSL加密建立

**21. SQL** **注入攻击了解吗？**

攻击者在HTTP请求中注入恶意的SQL代码，服务器使用参数构建数据库SQL命令时，恶意SQL被一起构造，并在数据库中执行。

用户登录，输入用户名 lianggzone，密码 ‘ or ‘1’=’1 ，如果此时使用参数构造的方式，就会出现

select * from user where name = ‘lianggzone’ and password = ‘’ or ‘1’=‘1’

不管用户名和密码是什么内容，使查询出来的用户列表不为空。如何防范SQL注入攻击使用预编译的PrepareStatement是必须的，但是一般我们会从两个方面同时入手。

Web端

1）有效性检验。

2）限制字符串输入的长度。

服务端

1）不用拼接SQL字符串。

2）使用预编译的PrepareStatement。

3）有效性检验。(为什么服务端还要做有效性检验？第一准则，外部都是不可信的，防止攻击者绕过Web端请求)

4）过滤SQL需要的参数中的特殊字符。比如单引号、双引号。

**22. Session** **是什么？**

除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。

Session 可以存储在服务器上的**文件、数据库或者内存中**。也可以将 Session 存储在 Redis 这种内存型

数据库中，效率会更高。

 **Session** **的过程是怎样的？**

过程如下：

用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；

服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为Session ID；

服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；

客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，

从 Redis 中取出用户信息，继续之前的业务操作。

**23. Session** **和** **cookie** **应该如何去选择（适用场景）？**

Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；

Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将

Cookie 值进行加密，然后在服务器进行解密；

对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。

* cookie工作原理：

  （1）浏览器端第一次发送请求到服务器端
  （2）服务器端创建Cookie，该Cookie中包含用户的信息，然后将该Cookie发送到浏览器端
  （3）浏览器端再次访问服务器端时会携带服务器端创建的Cookie
  （4）服务器端**通过Cookie中携带的数据区分不同的用户**

  <img src="C:\Users\96919\AppData\Roaming\Typora\typora-user-images\image-20220318114258690.png" alt="image-20220318114258690" style="zoom: 67%;" />

* session工作原理：

  （1）浏览器端第一次发送请求到服务器端，服务器端创建一个Session，同时会创建一个特殊的Cookie（**name**为JSESSIONID的**固定值**，**value**为session对象的**ID**），然后将该Cookie发送至浏览器端
  （2）浏览器端发送第N（N>1）次请求到服务器端,浏览器端访问服务器端时就会携带该name为JSESSIONID的Cookie对象
  （3）服务器端根据name为JSESSIONID的Cookie的value(sessionId),去查询Session对象，从而区分不同用户

  <img src="C:\Users\96919\AppData\Roaming\Typora\typora-user-images\image-20220318114241319.png" alt="image-20220318114241319" style="zoom: 67%;" />

* 区别：

  (1)**cookie数据存放在客户的浏览器上**，**session数据放在服务器上**
  (2)cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,如果主要考虑到安全应当使用session
  (3)session会在一定时间内保存在服务器上。当访问增多，会比较**占用你服务器的性能**，如果主要考虑到减轻服务器性能方面，应当使用COOKIE
  (4)单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能3K。
  (5)所以：将**登陆信息等重要信息存放为SESSION;其他信息如果需要保留，可以放在COOKIE中**



# 公司信息

## 华为

成立于1987年。 华为是全球领先的[信息与通信技术](https://baike.baidu.com/item/信息与通信技术/18492416)（ICT）解决方案[供应商](https://baike.baidu.com/item/供应商/8431806)，专注于ICT领域，坚持稳健经营、持续创新、开放合作，在[电信运营商](https://baike.baidu.com/item/电信运营商/10694548)、企业、[终端](https://baike.baidu.com/item/终端/1903878)和[云计算](https://baike.baidu.com/item/云计算/9969353)等领域构筑了端到端的解决方案优势，为[运营商](https://baike.baidu.com/item/运营商/4530550)客户、企业客户和消费者提供有竞争力的[ICT](https://baike.baidu.com/item/ICT/32270)解决方案、产品和服务，并致力于实现未来信息社会、构建更美好的全联接世界。

华为云成立于2005年，隶属于华为公司 [1] ，专注于云计算中公有云领域的技术研究与生态拓展，致力于为用户提供一站式云计算基础设施服务。







防抖 节流 call bind apply 柯里化 数组扁平化 new  数组去重 版本号

promiseAll 发布者订阅模式 深拷贝  树的迭代 布局



 快排 归并 

https://wenku.baidu.com/view/1e906735a11614791711cc7931b765ce05087a84.html

